//*****************************************************************
// File:   cl.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
// Date:   julio 2023
// Coms:   compilar mediante "ant"
//*****************************************************************

options {
	IGNORE_CASE = true;	//No distinguir entre mayúsculas y minúsculas
	COMMON_TOKEN_ACTION = true; //Se generan acciones por defecto
}

PARSER_BEGIN(alike)

package traductor;

//...

public class alike {
   //...
   
   public static void main(String[] args) {
	   alike parser = null;
	   
	   try {
		   if(args.length == 0) {
			   parser = new alike(System.in);
		   }
		   else {
			   parser = new alike(new java.io.FileInputStream(args[0]));
		   }
		   //Programa es el símbolo inicial de la gramática
		   parser.Programa();
		   //...
		   System.out.println("***** Análisis terminado con éxito *****");
	   }
	   catch (java.io.FileNotFoundException e) {
		   System.err.println ("Fichero " + args[0] + " no encontrado.");
	   }
	   catch (TokenMgrError e) {
		   System.err.println("LEX_ERROR: " + e.getMessage());
	   }
	   catch (ParseException e) {
			System.err.println("PARSE_ERROR: " + e.getMessage());
	   }
	   //...
   }
}
PARSER_END(alike)
<COMILLAS> SKIP: { "\"" : DEFAULT }
SKIP : { <tCOMMENT :"--" (~["\n"])* "\n"> | " " |  "\n" |  "\t"|  "\r" } 

TOKEN : {
	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >

}

TOKEN : {
	//Propios del programa
	< tBEGIN: "begin" >
|	< tEND: "end" >
|	< tASIGN: ":=" >
|	< tREF: "ref" >
|	< tIS: "is" >
|	< tOF: "of" >
|	< tPROC: "procedure" >
|	< tNULL: "null" >
|	< tRETURN: "return" >


	//Tipos de datos
|	< tCHAR: "character" >
|	< tBOOL: "boolean" >
|	< tINT: "integer" >
|	< tCHARCONST: "\'" ~["\n"] "\'" >
|	< tINTCONST: ("-")?(<DIGIT>)+ >
|	< tBOOLCONST: "true" | "false" >
|   < tSTRING: "\"" ((~["\n", "\""])* ("\"\"")? )* "\""  > {
	// quitamos la doble "" por "
	matchedToken.image = image.toString().replaceAll("\"\"", "\"");
}

	//Operadores
|	< tPLUS: "+" >
|	< tMINUS: "-" >
|	< tTIMES: "*" >
|	< tDIV: "/" >
|   < tLT: "<" >
|   < tGT: ">" >
|   < tEQ: "=" >
|	< tNE: "/=" >
|	< tLE: "<=" >
|	< tGE: ">=" >
|	< tMOD: "mod" >
|	< tAPAR: "(" >
|	< tCPAR: ")" >
|	< tSCOL: ";" >
|	< tCOL: ":" >
|	< tCOMA: "," >
|	< tRANGE: ".." >
// Built in functions
|	< tSKIPLINE: "skip_line" >
|	< tGET: "get" >
|	< tPUTLINE: "put_line" >
|	< tPUT: "put" >
|   < tINT2CHAR: "int2char" >
|   < tCHAR2INT: "char2int" >

//Condicionales
|	< tIF: "if" >
|	< tELSE: "else" >
|   < tELSIF: "elsif" >
|   < tTHEN: "then" >
|	< tWHILE: "while" >
| 	< tLOOP: "loop" >

//Identificadores
|   < tIDENTIFIER: ( <LETTER> |"_") (<LETTER> | <DIGIT> | "_")* >
|	< tRESTO: ~[] >
   
}

//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void Programa() : 
{

}
{
   ( 
	   < tBEGIN > | <tEND> | <tASIGN> | <tREF> | <tIS> | <tOF> | <tPROC> | <tNULL> | <tRETURN> 
	   | <tCHAR> | <tBOOL> | <tINT> | <tCHARCONST> | <tINTCONST> | <tBOOLCONST> | <tSTRING>
	   | <tPLUS> | <tMINUS> | <tTIMES> | <tDIV> | comparacion() | <tMOD>
	   | <tAPAR> | <tCPAR> | <tSCOL> | <tCOL> | <tCOMA> | <tRANGE>
	   | <tIF> | <tELSE> | <tELSIF> | <tTHEN> 
	   | <tWHILE> | <tLOOP> 
	   | <tIDENTIFIER> 
	   | builtin_function()
	   | <tRESTO> 
   )+
   < EOF >
}

void tipo_dato():
{

}
{
	<tCHAR> | <tBOOL> | <tINT>
}

void tipo_constante():
{

}
{
	<tCHARCONST> | <tINTCONST> | <tBOOLCONST> | <tSTRING>
}

void operador():
{

}
{
	<tPLUS> | <tMINUS> | <tTIMES> | <tDIV> | <tMOD>
}


void comparacion():
{

}
{
	<tLT> | <tGT> | <tEQ> | <tNE> | <tLE> | <tGE>
}

void builtin_function():
{

}
{
	<tSKIPLINE> | <tGET> | <tPUT> | <tPUTLINE> | <tINT2CHAR> | <tCHAR2INT>
}




TOKEN_MGR_DECLS : {
	static void CommonTokenAction(Token token) {
		if (token.kind == tRESTO) System.out.println("ERROR LEXICO: (" + token.beginLine + ", " + token.beginColumn + "): simbolo no reconocido: " + token.image);
		System.out.println("(" + token.beginLine + ", " + token.beginColumn + "): " + alikeConstants.tokenImage[token.kind] + " " + token.image);
	}
	
}
