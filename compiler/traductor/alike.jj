//*****************************************************************
// File:   cl.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
// Date:   julio 2023
// Coms:   compilar mediante "ant"
//*****************************************************************

options {
    IGNORE_CASE = true;    //No distinguir entre mayúsculas y minúsculas
    COMMON_TOKEN_ACTION = false; //Se generan acciones por defecto
    DEBUG_PARSER = true; //Genera información de depuración
}

PARSER_BEGIN(alike)

package traductor;

import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import java.util.*;
import lib.tools.TypeValue;
import lib.tools.SemanticFunctions;
import lib.tools.exceptions.*;


public class alike {
   //...
   public static SymbolTable st = new SymbolTable();
   public static void main(String[] args) {
   	alike parser = null;
       
   	try {
   		if(args.length == 0) {
   			parser = new alike(System.in);
   		}
   		else {
   			parser = new alike(new java.io.FileInputStream(args[0]));
   		}
   		//Programa es el símbolo inicial de la gramática
   		parser.Programa();
   		//...
   		System.out.println("***** Análisis terminado con éxito *****");
   	}
   	catch (java.io.FileNotFoundException e) {
   		System.err.println ("Fichero " + args[0] + " no encontrado.");
   	}
   	catch (TokenMgrError e) {
   		System.err.println("LEX_ERROR: " + e.getMessage());
   	}
   	catch (ParseException e) {
   		 System.err.println("PARSE_ERROR: " + e.getMessage());
   	}
   	//...
   }
}
PARSER_END(alike)
<COMILLAS> SKIP: { "\"" : DEFAULT }
SKIP : { <tCOMMENT :"--" (~["\n"])* "\n"> | " " |  "\n" |  "\t"|  "\r" }

TOKEN : {
    < #LETTER: (["a"-"z","A"-"Z"]) >
|    < #DIGIT: ["0"-"9"] >

}

TOKEN : {
    //Propios del programa
    < tBEGIN: "begin" >
|    < tEND: "end" >
|    < tASIGN: ":=" >
|    < tREF: "ref" >
|    < tIS: "is" >
|    < tOF: "of" >
|    < tPROC: "procedure" >
|    < tFUNC: "function" >
|    < tNULL: "null" >
|    < tARRAY: "array" >
|    < tRETURN: "return" >


    //Tipos de datos
|    < tCHAR: "character" >
|    < tBOOL: "boolean" >
|    < tINT: "integer" >
|    < tCHARCONST: "\'" ~["\n"] "\'" >
|    < tINTCONST: (<DIGIT>)+ >
|    < tTRUE: "true" >
|    < tFALSE: "false" >
|   < tSTRING: "\"" ((~["\n", "\""])* ("\"\"")? )* "\""  > {
    // quitamos la doble "" por "
    matchedToken.image = image.toString().replaceAll("\"\"", "\"");
}

    //Operadores
|    <tAND: "and" >
|    <tOR: "or" >
|    <tNOT: "not" >
|    < tPLUS: "+" >
|    < tMINUS: "-" >
|    < tTIMES: "*" >
|    < tDIV: "/" >
|   < tLT: "<" >
|   < tGT: ">" >
|   < tEQ: "=" >
|    < tNE: "/=" >
|    < tLE: "<=" >
|    < tGE: ">=" >
|    < tMOD: "mod" >
|    < tAPAR: "(" >
|    < tCPAR: ")" >
|    < tPC: ";" >
|    < tDP: ":" >
|    < tCOMA: "," >
|    < tRANGE: ".." >
// Built in functions
|    < tSKIPLINE: "skip_line" >
|    < tGET: "get" >
|    < tPUTLINE: "put_line" >
|    < tPUT: "put" >
|   < tINT2CHAR: "int2char" >
|   < tCHAR2INT: "char2int" >

//Condicionales
|    < tIF: "if" >
|    < tELSE: "else" >
|   < tELSIF: "elsif" >
|   < tTHEN: "then" >
|    < tWHILE: "while" >
|     < tLOOP: "loop" >

//Identificadores
|   < tID: ( <LETTER> |"_") (<LETTER> | <DIGIT> | "_")* >
|    < tRESTO: ~[] >
   
}

Token boolconst():
{
    Token bool_const = null;
}
{
    ( bool_const = <tTRUE> | bool_const = <tFALSE>) { return bool_const; }
}

// Devuelve el array con los símbolos de los identificadores con su tipo
// @param ids: lista de identificadores a los que se les va a asignar un tipo
// @param ref: token que indica si el tipo es por referencia
ArrayList<Symbol> tipo_dato(ArrayList<String> ids, boolean isRef):
{
    ArrayList<Symbol> t;
    Token neg1 = null, neg2 = null, min, max;
}
{
    t = tipo_base(ids, isRef) { return t; }
    | <tARRAY> <tAPAR> ( neg1 = <tMINUS>)? min = <tINTCONST> <tRANGE> ( neg2 = <tMINUS>)?  max = <tINTCONST> <tCPAR> <tOF> t = tipo_base(ids, isRef) {
   	 return SemanticFunctions.simbolos_con_tipo(ids, isRef, t, min, max, neg1, neg2);
    }
}


// Devuelve el array con los símbolos de los identificadores con su tipo
// @param ids: lista de identificadores a los que se les va a asignar un tipo
// @param isRef: indica si el tipo es por referencia
ArrayList<Symbol> tipo_base(ArrayList<String> ids, boolean isRef):
{
    Symbol t;
}
{
    (<tCHAR> {t = new SymbolChar("");} | <tBOOL> {t = new SymbolBool("");} | <tINT>{t = new SymbolInt("");} ) {
   	 return SemanticFunctions.ids_simbolos_base(ids, isRef, t);
    }
}


TypeValue tipo_constante():
{
    Token char_const = null;
    Token int_const = null;
    Token bool_const = null;
    Token string_const = null;
}
{
    char_const = <tCHARCONST> {
   	 	return new TypeValue(Symbol.Types.CHAR, char_const.image.charAt(0));
    } | int_const = <tINTCONST> {
   	 	return new TypeValue(Symbol.Types.INT, Integer.parseInt(int_const.image));
    } | bool_const = boolconst() {
   	 	return new TypeValue(Symbol.Types.BOOL, Boolean.parseBoolean(bool_const.image));
    } | string_const = <tSTRING> {
   	 	return new TypeValue(Symbol.Types.STRING, string_const.image);
    }
}


//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void Programa() :
{
    SymbolProcedure proc_main = new SymbolProcedure("__NOT_A_PROCEDURE__", new ArrayList<Symbol>());
    ArrayList<Symbol> vars = null;
}
{
   try {
		proc_main = cabecera_procedimiento() {
			SemanticFunctions.insertSymbol(st, proc_main);
			st.setMainProc(proc_main.name);
		}
		( vars = declaracion_variables() )? {
			if (vars != null) {
				for (Symbol var : vars) {
					SemanticFunctions.insertSymbol(st, var);
				}
			} else {
				vars = new ArrayList<Symbol>();
			}
			System.out.println("Nuevo símbolo: " + st.toString());
		}
		( declaracion_procs_funcs() )?
		<tBEGIN>
		(instruccion())*
		<tEND>
		<tPC>
		< EOF >
    } catch (ParseException e) {
		System.err.println("PARSE_ERROR: " + e.getMessage());

		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
    }

}

ArrayList<Symbol> declaracion_variables() :
{
    ArrayList<Symbol> vars = new ArrayList<Symbol>();
    ArrayList<Symbol> var_list = null;
}
{
    ( var_list = declaracion_var() {
   	 	for (Symbol var: var_list) vars.add(var);
    } )+ {
   	 	return vars;
    }
}
    

ArrayList<Symbol> declaracion_var() :
{
    ArrayList<String> ids;
    ArrayList<Symbol> vars;
}
{
    try {
		// tipo_dato devuelve el símbolo
		ids = lista_ids() <tDP> vars = tipo_dato(ids, false) <tPC> {
			return vars;
		}
    } catch (ParseException e) {
		System.err.println("PARSE_ERROR: " + e.getMessage());

		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
    }
}


void declaracion_procs_funcs() :
{

}
{
    ( declaracion_proc() | declaracion_func() )+
}

// Reconoce la declaración de un procedimiento
// Inserta el símbolo del procedimiento en la tabla de símbolos
// Inserta bloque en la tabla de símbolos
// Inserta los parámetros y variables en la tabla de símbolos
void declaracion_proc():
{
    SymbolProcedure proc = new SymbolProcedure("__NOT_A_PROCEDURE__", new ArrayList<Symbol>());
    ArrayList<Symbol> vars = null;
}
{
    try {
		proc = cabecera_procedimiento() {
			SemanticFunctions.newProcBlock(st, proc);
		}
		( vars = declaracion_variables() )? {
			if (vars != null) {
				for (Symbol var : vars) SemanticFunctions.insertSymbol(st, var);
			} else {
				vars = new ArrayList<Symbol>();
			}
		}
		( declaracion_procs_funcs() )?
		<tBEGIN>
		(instruccion())+
		<tEND>
		<tPC>
		{
			System.out.println("Procedimiento reconocido: " + st.toString());
			st.removeBlock();
		}
    } catch (ParseException e) {
		System.err.println("PARSE_ERROR: " + e.getMessage());

		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
    }
}


// Reconoce la declaración de una función
// Inserta el símbolo de la función en la tabla de símbolos
// Inserta bloque en la tabla de símbolos
// Inserta los parámetros y variables en la tabla de símbolos
void declaracion_func():
{
    ArrayList<Symbol> vars = new ArrayList<Symbol>();
    SymbolFunction func = new SymbolFunction("__NOT_A_FUNCTION__", new ArrayList<Symbol>(), Symbol.Types.UNDEFINED);
}
{
    
    try {
		func = cabecera_funcion() {
			SemanticFunctions.newFuncBlock(st, func);
		}
		( vars = declaracion_variables() )? {
			// perdón, era necesario
			if (vars != null) for (Symbol var : vars) SemanticFunctions.insertSymbol(st, var);
		}
		<tBEGIN>
		(instruccion())+
		<tEND>
		<tPC>
		{
			System.out.println("Función reconocida: " + st.toString());
			st.removeBlock();
		}
    } catch (ParseException e) {
		System.err.println("PARSE_ERROR: " + e.getMessage());

		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
    }
}

ArrayList<Symbol> declaracion_param() :
{
    ArrayList<String> ids;
    ArrayList<Symbol> ids_con_tipo;
    Token ref = null;
}
{
    ids = lista_ids() <tDP> ( ref=<tREF> )? ids_con_tipo = tipo_dato(ids, ref != null)
    {
   	 	return ids_con_tipo;
    }
}

// Devuelve la lista de identificadores reconocidos
ArrayList<String> lista_ids() :
{
    ArrayList<String> ids = new ArrayList<String>();
    ArrayList<String> resto_ids = null;
    Token id;
}
{
    ( LOOKAHEAD(2) id = <tID> <tCOMA> resto_ids = lista_ids()
|    id = <tID>) {
		ids.add(id.image);
		if (resto_ids != null) {
			for (String sid : resto_ids) ids.add(sid);
		}
		return ids;
    }
}

// Devuelve el símbolo del procedimiento con los parámetros
SymbolProcedure cabecera_procedimiento():
{
    Token id_proc;
    ArrayList<Symbol> proc_params = null;
}
{
    <tPROC> id_proc = <tID> ( proc_params = parametros_formales() )? <tIS>
    {
   	 	return new SymbolProcedure(id_proc.image, proc_params);
    }
}


// Devuelve el símbolo de la función con los parámetros
SymbolFunction cabecera_funcion():
{
    Token id_func;
    ArrayList<Symbol> func_params = null;
    ArrayList<Symbol> returnType = null;
    
}
{
    <tFUNC> id_func = <tID> ( func_params = parametros_formales() )? <tRETURN> returnType = tipo_dato(new ArrayList<String>(Arrays.asList("returnType")), false) <tIS> {
   	 	return new SymbolFunction(id_func.image, func_params, returnType.get(0).type);
    }
}


ArrayList<Symbol> parametros_formales():
{
    ArrayList<Symbol> params = new ArrayList<Symbol>();
    ArrayList<Symbol> ps, resto_p;
}
{
    try {
		( <tAPAR>    ps = declaracion_param() {
				for (Symbol p :  ps) params.add(p);
			}
		
			resto_p = lista_parametros_formales() {
				for (Symbol p :  resto_p) params.add(p);
			} <tCPAR> // con parámetros
		| "" ) // sin parámetros (épsilon)
    } catch (ParseException e) {
		System.err.println("PARSE_ERROR: " + e.getMessage());

		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
    }
    { return params; }
}

ArrayList<Symbol> lista_parametros_formales():
{
    ArrayList<Symbol> params = new ArrayList<Symbol>();
    ArrayList<Symbol> ps, resto_p;
}
{
    (<tPC> ps = declaracion_param(){
		for (Symbol p :  ps) params.add(p);
	}
   	resto_p = lista_parametros_formales() {
   		for (Symbol p :  resto_p) params.add(p);
   	}
    ) { return params; }
    | { return params; }
}



void instruccion() :
{}
{
    try {
		(inst_leer()
		|   <tSKIPLINE>
		|    inst_escribir()
		|   inst_escribir_linea()
		|   inst_invocacion_o_asignacion()
		|   inst_if()
		|   inst_while()
		|   inst_return()
		|   <tNULL>) <tPC>
    } catch (ParseException e) {
		System.err.println("PARSE_ERROR: " + e.getMessage());

		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
    }

}

// la dejamos pq puede haber indexaciones a arrays y eso hay que pensarlo donde poner el sintáctico de las indexaciones
void inst_leer() :
{
    ArrayList<String> ids = null;
}
{
    <tGET> <tAPAR> ids = lista_ids() <tCPAR> {
    }
}

void inst_escribir() :
{
    ArrayList<TypeValue> exps = new ArrayList<TypeValue>();
	Token put = null;
}
{
    put = <tPUT> <tAPAR> exps = lista_una_o_mas_exps() <tCPAR> {
		SemanticFunctions.inst_escribir(exps, put.beginLine, put.beginColumn);
		System.out.println("Encontrada instrucción put correcta");
    }
}

void inst_escribir_linea() :
{
    ArrayList<TypeValue> exps = new ArrayList<TypeValue>();
	Token put = null;
}
{
    put = <tPUTLINE> (<tAPAR> exps = lista_una_o_mas_exps()    <tCPAR>)? {
		SemanticFunctions.inst_escribir(exps, put.beginLine, put.beginColumn);
		System.out.println("Encontrada instrucción put_line correcta");
		// Añadir un salto de línea al final en la generación de código
    }
}

void inst_invocacion_o_asignacion() :
{}
{
    primario() ( <tASIGN> expresion())?
}

void inst_if() :
{}
{
    // debe haber por lo menos una instrucción en el bloque condicional (null en casos donde no se haga nada)
    <tIF> expresion() <tTHEN> (instruccion())+
    (<tELSIF> expresion() <tTHEN> (instruccion())+)*
    (<tELSE> (instruccion())+)?
    <tEND> <tIF>
}

void inst_while() :
{}
{
    <tWHILE> expresion() <tLOOP> (instruccion())+ <tEND> <tLOOP>
}

void inst_return() :
{}
{
	// comprobar que si es un array, el rango tiene que ser el mismo además del tipo base
    <tRETURN> expresion()
}

TypeValue expresion():
{
    TypeValue prel = null, rest_rel = null;
    Token op = null;
}
{
	prel = relacion() ( (op = <tAND> | op = <tOR>) rest_rel = lista_una_o_mas_relaciones_booleanas())? {
	 	return SemanticFunctions.expresion(prel, op, rest_rel, tAND, tOR);
    }
}


TypeValue lista_una_o_mas_relaciones_booleanas():
{
    TypeValue prel = null, rest_rel = null;
    Token op = null;
}
{
    prel = relacion() ((op = <tAND> | op = <tOR>) rest_rel = lista_una_o_mas_relaciones_booleanas())? {
   	 return SemanticFunctions.expresion(prel, op, rest_rel, tAND, tOR);
    }
}

TypeValue relacion():
{
    TypeValue exp1 = null, exp2 = null;    
    Token op = null;
}
{
	exp1 = expresion_simple()
	( op = operador_relacional() exp2 = expresion_simple() )? {
		return SemanticFunctions.relacion(exp1, op, exp2, tEQ, tNE, tLT, tLE, tGT, tGE);
    }
}

Token operador_relacional():
{
    Token t;
}
{
    (t = <tEQ> | t = <tNE> | t = <tLT> | t = <tLE> | t = <tGT> | t = <tGE>) { return t; }
}

TypeValue expresion_simple():
{
    TypeValue term = null, term_resultante = null;
    Token op = null, ops = null;
    // HACER TESTS DE CADA UNA DE LAS CONDICIONES QUE SE DAN
}
{
	( ops = <tPLUS> | ops =    <tMINUS> )?
	term = termino()  (( op = <tPLUS> | op = <tMINUS> ) term_resultante = una_o_mas_expresiones_simples())? {
		return SemanticFunctions.expresion_simple(ops, term, op, term_resultante, tPLUS, tMINUS);
    }
}

TypeValue una_o_mas_expresiones_simples():
{
    TypeValue term = null, term_resultante = null;
    Token op = null, ops = null;
}
{
    term = termino() (( op = <tPLUS> | op = <tMINUS> ) term_resultante = una_o_mas_expresiones_simples())? {
   	 return SemanticFunctions.una_o_mas_expresiones_simples(term, op, term_resultante, tPLUS, tMINUS);
    }
}

TypeValue termino():
{
    TypeValue fact = null, fact_resultante = null;
    Token op = null;
}
{
    fact = factor() ( op = operador_multiplicativo() fact_resultante = lista_una_o_mas_terminos() )? {
		return SemanticFunctions.termino(fact, op, fact_resultante, tTIMES, tDIV, tMOD);
    }
}

TypeValue lista_una_o_mas_terminos():
{
    TypeValue fact = null, fact_resultante = null;
    Token op = null;
}
{
    fact = factor() ( op = operador_multiplicativo() fact_resultante = lista_una_o_mas_terminos())? {
   	 	return SemanticFunctions.termino(fact, op, fact_resultante, tTIMES, tDIV, tMOD);
    }
}

Token operador_multiplicativo() :
{
    Token t;
}
{
    (t = <tTIMES> | t = <tDIV> | t = <tMOD>) { return t; }
}

TypeValue factor():
{
    TypeValue p = null;
	Token not = null;
}
{
    p = primario() {
   	 return p;
    }
    | not = <tNOT> p = primario() {
		return SemanticFunctions.not_primario(p, not.beginLine, not.beginColumn);
    }
}

TypeValue primario() :
{
    TypeValue exp = null;
    Token id = null, fnToken = null;
    ArrayList<TypeValue> exps = null;
}
{
	<tAPAR> exp = expresion() <tCPAR> { return exp; }
|    fnToken = <tINT2CHAR> <tAPAR> exp = expresion() <tCPAR> {
    // System.out.println(exp.value);
    if (exp.type == Symbol.Types.INT) {
   	 return new TypeValue(Symbol.Types.CHAR, exp.value);
    } else {
   	 UnexpectedTypeException.getMessage(Symbol.Types.INT, exp.type, fnToken.beginLine, fnToken.beginColumn);
    } 
}
|    fnToken = <tCHAR2INT> <tAPAR> exp = expresion() <tCPAR> {
   	 if (exp.type == Symbol.Types.CHAR) {
   		 return new TypeValue(Symbol.Types.INT, String.valueOf(exp.value));
   	 } else {
   		 UnexpectedTypeException.getMessage(Symbol.Types.INT, exp.type, fnToken.beginLine, fnToken.beginColumn);
   	 }
    }
|    LOOKAHEAD(2)
	id = <tID> <tAPAR> exps = lista_una_o_mas_exps() <tCPAR> /*invoc. func. o comp. array*/ {
		return SemanticFunctions.invoc_func_o_comp_array(id, exps, st);
    }
|    id = <tID> /*var. o func. sin pars*/ {
		return SemanticFunctions.var_o_func_sin_params(id, st);
    }
|    exp = tipo_constante() { return exp; }
}

ArrayList<TypeValue> lista_una_o_mas_exps() :
{
    ArrayList<TypeValue> exps = new ArrayList<TypeValue>();
    TypeValue exp;
}
{
    exp = expresion() exps = lista_exps_ll()	{
	exps.add(0, exp);
	 return exps;
    }
}

ArrayList<TypeValue> lista_exps_ll() :
{
    ArrayList<TypeValue> exps = new ArrayList<TypeValue>();
    TypeValue exp;
}
{
    <tCOMA> exp = expresion() exps = lista_exps_ll() {
   	 exps.add(0, exp);
   	 return exps;
    }
    | {return exps;}
}


TOKEN_MGR_DECLS : {
    static void CommonTokenAction(Token token) {
   	 if (token.kind == tRESTO) System.out.println("ERROR LEXICO: (" + token.beginLine + ", " + token.beginColumn + "): simbolo no reconocido: " + token.image);
   	 System.out.println("(" + token.beginLine + ", " + token.beginColumn + "): " + alikeConstants.tokenImage[token.kind] + " " + token.image);
   	 System.out.println();
    }
    
}


