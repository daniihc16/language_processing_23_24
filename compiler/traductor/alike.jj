//*****************************************************************
// File:   cl.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
// Date:   julio 2023
// Coms:   compilar mediante "ant"
//*****************************************************************

options {
	IGNORE_CASE = true;	//No distinguir entre mayúsculas y minúsculas
	COMMON_TOKEN_ACTION = false; //Se generan acciones por defecto
	DEBUG_PARSER = true; //Genera información de depuración
}

PARSER_BEGIN(alike)

package traductor;

import lib.symbolTable.*;
import java.util.*;


public class alike {
   //...
   public static SymbolTable st = new SymbolTable();
   public static void main(String[] args) {
	   alike parser = null;
	   
	   try {
		   if(args.length == 0) {
			   parser = new alike(System.in);
		   }
		   else {
			   parser = new alike(new java.io.FileInputStream(args[0]));
		   }
		   //Programa es el símbolo inicial de la gramática
		   parser.Programa();
		   //...
		   System.out.println("***** Análisis terminado con éxito *****");
	   }
	   catch (java.io.FileNotFoundException e) {
		   System.err.println ("Fichero " + args[0] + " no encontrado.");
	   }
	   catch (TokenMgrError e) {
		   System.err.println("LEX_ERROR: " + e.getMessage());
	   }
	   catch (ParseException e) {
			System.err.println("PARSE_ERROR: " + e.getMessage());
	   }
	   //...
   }
}
PARSER_END(alike)
<COMILLAS> SKIP: { "\"" : DEFAULT }
SKIP : { <tCOMMENT :"--" (~["\n"])* "\n"> | " " |  "\n" |  "\t"|  "\r" } 

TOKEN : {
	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >

}

TOKEN : {
	//Propios del programa
	< tBEGIN: "begin" >
|	< tEND: "end" >
|	< tASIGN: ":=" >
|	< tREF: "ref" >
|	< tIS: "is" >
|	< tOF: "of" >
|	< tPROC: "procedure" >
|	< tFUNC: "function" >
|	< tNULL: "null" >
|	< tARRAY: "array" >
|	< tRETURN: "return" >


	//Tipos de datos
|	< tCHAR: "character" >
|	< tBOOL: "boolean" >
|	< tINT: "integer" >
|	< tCHARCONST: "\'" ~["\n"] "\'" >
|	< tINTCONST: (<DIGIT>)+ >
|	< tTRUE: "true" >
|	< tFALSE: "false" >
|   < tSTRING: "\"" ((~["\n", "\""])* ("\"\"")? )* "\""  > {
	// quitamos la doble "" por "
	matchedToken.image = image.toString().replaceAll("\"\"", "\"");
}

	//Operadores
|	<tAND: "and" >
|	<tOR: "or" >
|	<tNOT: "not" >
|	< tPLUS: "+" >
|	< tMINUS: "-" >
|	< tTIMES: "*" >
|	< tDIV: "/" >
|   < tLT: "<" >
|   < tGT: ">" >
|   < tEQ: "=" >
|	< tNE: "/=" >
|	< tLE: "<=" >
|	< tGE: ">=" >
|	< tMOD: "mod" >
|	< tAPAR: "(" >
|	< tCPAR: ")" >
|	< tPC: ";" >
|	< tDP: ":" >
|	< tCOMA: "," >
|	< tRANGE: ".." >
// Built in functions
|	< tSKIPLINE: "skip_line" >
|	< tGET: "get" >
|	< tPUTLINE: "put_line" >
|	< tPUT: "put" >
|   < tINT2CHAR: "int2char" >
|   < tCHAR2INT: "char2int" >

//Condicionales
|	< tIF: "if" >
|	< tELSE: "else" >
|   < tELSIF: "elsif" >
|   < tTHEN: "then" >
|	< tWHILE: "while" >
| 	< tLOOP: "loop" >

//Identificadores
|   < tID: ( <LETTER> |"_") (<LETTER> | <DIGIT> | "_")* >
|	< tRESTO: ~[] >
   
}

void boolconst():
{}
{
	<tTRUE> | <tFALSE>
}

ArrayList<Symbol> tipo_dato(ArrayList<String> ids, Token ref):
{
	ArrayList<Symbol> t;
	Token neg1, neg2, min, max;
}
{
	t = tipo_base(ids, ref) { return t; }
	| <tARRAY> <tAPAR> ( neg1 = <tMINUS>)? min = <tINTCONST> <tRANGE> ( neg2 = <tMINUS>)?  max = <tINTCONST> <tCPAR> <tOF> t = tipo_base(ids, ref) {
		Symbol.ParameterClass p_class = Symbol.ParameterClass.VAL;
		if (ref.image == alikeConstants.tokenImage[tREF]) p_class = Symbol.ParameterClass.REF;
		int minInd = Integer.parseInt(min.image);
		int maxInd = Integer.parseInt(max.image);
		if (neg1 != null) minInd = minInd*(-1);
		if (neg2 != null) maxInd = maxInd*(-1);
		ArrayList<Symbol> ids_con_tipo = new ArrayList<Symbol>();
		for (int i=0; i<ids.size(); i++) {
			ids_con_tipo.add(new SymbolArray(ids[i], minInd, maxInd, t[i].type, p_class));
		}
		return ids_con_tipo;
	}
}

ArrayList<Symbol> tipo_base(ArrayList<String> ids, Token ref):
{
	Symbol t;
}
{
	
	
	(<tCHAR> {t = new SymbolChar("");} | <tBOOL> {t = new SymbolBool("");} | <tINT>{t = new SymbolInt("");} ) {
		ArrayList<Symbol> ids_symbols = new ArrayList<Symbol>();
		Symbol.ParameterClass p_class = Symbol.ParameterClass.VAL;
		if (ref.image == alikeConstants.tokenImage[tREF]) p_class = Symbol.ParameterClass.REF;
		for (String id : ids) {
			Symbol t_clone = t.clone();
			t_clone.name = id;
			t_clone.parClass = p_class;
			ids_symbols.add(t_clone);
		}
		return ids_symbols;
	}
}

void tipo_constante():
{

}
{
	<tCHARCONST> | <tINTCONST> | boolconst()| <tSTRING>
}


//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void Programa() : 
{
	SymbolProcedure proc_main;
}
{
   try {
	proc_main = cabecera_procedimiento() {
		st.insertSymbol(proc_main);
	}
	( declaracion_variables() )?
	( declaracion_procs_funcs() )?
	<tBEGIN>
	(instruccion())*
	<tEND>
	<tPC>
   < EOF >
	} catch (ParseException e) {
		System.err.println("PARSE_ERROR: " + e.getMessage());

		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
	}

}

void declaracion_variables() :
{

}
{
	( declaracion_var() )+
}
	

void declaracion_var() :
{
	ArrayList<String> ids;
}
{ 
	try {
		ids = lista_ids() <tDP> tipo_dato(ids, new Token()) <tPC>
	} catch (ParseException e) {
		System.err.println("PARSE_ERROR: " + e.getMessage());

		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
	}
}

void declaracion_procs_funcs() : 
{

}
{
	( declaracion_proc() | declaracion_func() )+
}

void declaracion_proc():
{}
{
	try {
		cabecera_procedimiento()
		( declaracion_variables() )?
		( declaracion_procs_funcs() )?
		<tBEGIN>
		(instruccion())+
		<tEND>
		<tPC>
	} catch (ParseException e) {
		System.err.println("PARSE_ERROR: " + e.getMessage());

		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
	}
}

void declaracion_func():
{}
{
	
	try {
		cabecera_funcion()
		( declaracion_variables() )?
		<tBEGIN>
		(instruccion())+
		<tEND>
		<tPC>
	} catch (ParseException e) {
		System.err.println("PARSE_ERROR: " + e.getMessage());

		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
	}
}

ArrayList<Symbol> declaracion_param() :
{
	ArrayList<String> ids;
	ArrayList<Symbol> ids_con_tipo;
	Token ref;
}
{
	ids = lista_ids() <tDP> ( ref=<tREF> )? ids_con_tipo = tipo_dato(ids, ref)
	{
		return ids_con_tipo;
	}
}


ArrayList<String> lista_ids() :
{
	ArrayList<String> ids = new ArrayList<String>();
	ArrayList<String> resto_ids;
	Token id;
}
{
	( LOOKAHEAD(2) id = <tID> <tCOMA> resto_ids = lista_ids()
|	id = <tID>) {
	if (!st.containsSymbol(id.image)) {
		ids.add(id.image);
	} else {
		System.err.println(id.image + " ya está definido");
	}
	if (resto_ids != null) {
		for (String sid : resto_ids) ids.add(sid);
	}
	return ids;
}
}

SymbolProcedure cabecera_procedimiento():
{
	Token id_proc;
	ArrayList<Symbol> proc_params;
}
{
	<tPROC> id_proc = <tID> ( proc_params = parametros_formales() )? <tIS>
	{
		if (!st.containsSymbol(id_proc.image)) return SymbolProcedure(id_proc.image, proc_params);
		else System.err.println(id_proc.image + " ya está definido");
	}
}

void cabecera_funcion():
{}
{
	<tFUNC> <tID> ( parametros_formales() )? <tRETURN> tipo_dato(new ArrayList<Symbol>(), new Token()) <tIS>
}


ArrayList<Symbol> parametros_formales():
{
	ArrayList<Symbol> params = new ArrayList<Symbol>();
	ArrayList<Symbol> ps, resto_p;
}
{
	try {
		( <tAPAR>	ps = declaracion_param() 
			{
				for (Symbol p :  ps) params.add(p);
			}
		
		resto_p = lista_parametros_formales() {
			for (Symbol p :  resto_p) params.add(p);
		} <tCPAR> // con parámetros 
		| "" ) // sin parámetros (épsilon)
		{ return params; } 
	} catch (ParseException e) {
		System.err.println("PARSE_ERROR: " + e.getMessage());

		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
	}
}

void lista_parametros_formales():
{
	ArrayList<Symbol> params = new ArrayList<Symbol>();;
}
{
	( <tPC> ps = declaracion_param() 
		{
			for (Symbol p :  ps) params.add(p);
		}
	resto_p = lista_parametros_formales() {
		for (Symbol p :  resto_p) params.add(p);
	}
	| "")  { return params; }
}



void instruccion() :
{}
{
	try {
		(inst_leer()
		|   <tSKIPLINE>
		|	inst_escribir()
		|   inst_escribir_linea()
		|   inst_invocacion_o_asignacion()
		|   inst_if()
		|   inst_while()
		|   inst_return()
		|   <tNULL>) <tPC>
	} catch (ParseException e) {
		System.err.println("PARSE_ERROR: " + e.getMessage());

		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
	}

}

void inst_leer() :
{}
{
	<tGET> <tAPAR> lista_ids() <tCPAR>
}

void inst_escribir() :
{}
{
	<tPUT> <tAPAR> lista_una_o_mas_exps() <tCPAR>
}

void inst_escribir_linea() :
{}
{
	<tPUTLINE> (<tAPAR> lista_una_o_mas_exps()	<tCPAR>)? {
		// añadir inst de salto de línea
	}
}

void inst_invocacion_o_asignacion() :
{}
{
	primario() ( <tASIGN> expresion())? // preguntar si bien o restringir más
}

void inst_if():
{}
{
	// debe haber por lo menos una instrucción en el bloque condicional (null en casos donde no se haga nada)
	<tIF> expresion() <tTHEN> (instruccion())+
	(<tELSIF> expresion() <tTHEN> (instruccion())+)*
	(<tELSE> (instruccion())+)?
	<tEND> <tIF>
}

void inst_while() :
{}
{
	<tWHILE> expresion() <tLOOP> (instruccion())+ <tEND> <tLOOP>
}

void inst_return() :
{}
{
	<tRETURN> expresion()
}

void expresion(): 
{}
{
    relacion()
	((<tAND> | <tOR>) relacion())*
}

void relacion():
{}
{
    expresion_simple()
 	( operador_relacional() expresion_simple() )?
}

void operador_relacional():
{}
{
	<tEQ> | <tNE> | <tLT> | <tLE> | <tGT> | <tGE>
}

void expresion_simple():
{}
{
    ( <tPLUS> |	<tMINUS> )? 
    termino()
	( ( <tPLUS> | <tMINUS> ) termino() )*
}

void termino():
{}
{
	factor() ( operador_multiplicativo() factor() )*
}

void operador_multiplicativo():
{}
{
    <tTIMES> | <tMOD> | <tDIV>
}

void factor():
{}
{
	primario()
	| <tNOT> primario()
}

void primario() :
{}
{
    <tAPAR> expresion() <tCPAR>
|	<tINT2CHAR> <tAPAR> expresion() <tCPAR>
|	<tCHAR2INT> <tAPAR> expresion() <tCPAR>
|	LOOKAHEAD(2)
    <tID> <tAPAR> lista_una_o_mas_exps() <tCPAR> //invoc. func. o comp. array
|	<tID>              //var. o func. sin pars
|	tipo_constante()
}

void lista_una_o_mas_exps() :
{}
{
	( expresion() (<tCOMA> expresion())* )+
}

TOKEN_MGR_DECLS : {
	static void CommonTokenAction(Token token) {
		if (token.kind == tRESTO) System.out.println("ERROR LEXICO: (" + token.beginLine + ", " + token.beginColumn + "): simbolo no reconocido: " + token.image);
		System.out.println("(" + token.beginLine + ", " + token.beginColumn + "): " + alikeConstants.tokenImage[token.kind] + " " + token.image);
		System.err.println(st.toString());
	}
	
}