//*****************************************************************
// File:   cl.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
// Date:   julio 2023
// Coms:   compilar mediante "ant"
//*****************************************************************

options {
    IGNORE_CASE = true;    //No distinguir entre mayúsculas y minúsculas
    COMMON_TOKEN_ACTION = false; //Se generan acciones por defecto
    DEBUG_PARSER = false; //Genera información de depuración
}

PARSER_BEGIN(alike)

package traductor;

import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import java.util.*;
import lib.tools.TypeValue;
import lib.tools.SemanticFunctions;
import lib.tools.exceptions.*;
import lib.tools.Constants;
import lib.tools.codeGeneration.*;
import lib.tools.Attributes;
import java.io.*;



public class alike {
   //...
	public static SymbolTable st = new SymbolTable();
	public static void main(String[] args) {
		alike parser = null;
		
		// Parseamos las opciones de la línea de comandos para inicializar las Constants
		// flags posibles: -v, -x, -v = verbose, -x = xmlOutput
		int i = 0;
		while (i < args.length && args[i].startsWith("-")) {
			System.out.println("Argumento: " + args[i]);
			if (args[i].equals("-v")) {
				Constants.verbose = true;
			} else if (args[i].equals("-x")) {
				Constants.xmlOutput = true;
			} else if (args[i].equals("-c")) {
				Constants.comments = true;
			}
			CodeBlock.generationMode = Constants.xmlOutput ? CodeBlock.BlockMode.XML : CodeBlock.BlockMode.PLAIN;
			i++;
		}
		// Si no se ha especificado un fichero de entrada se da error, se usa el nombre del fichero de entrada	
		if (i == args.length) {
			System.err.println("Uso: java -jar alike [-v] [-x] fichero_entrada.alike [fichero_salida.pcode]");
			System.exit(1);
		}

		

		try {
			if(args.length == 0) {
				parser = new alike(System.in);
			}
			else {
				parser = new alike(new java.io.FileInputStream(args[i]));
			}
			//Programa es el símbolo inicial de la gramática
			parser.Programa(args[args.length - 1].split("\\.")[0] + ".pcode");
			//...
			System.out.println("***** Análisis terminado con éxito *****");
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
			System.err.println("LEX_ERROR: " + e.getMessage());
			Constants.errorFree = false;

		}
		catch (ParseException e) {
			System.err.println("SYNTAX_ERROR: " + e.getMessage());
			Constants.errorFree = false;
		}
		//...
   }
}
PARSER_END(alike)
<COMILLAS> SKIP: { "\"" : DEFAULT }
SKIP : { <tCOMMENT :"--" (~["\n"])* "\n"> | " " |  "\n" |  "\t"|  "\r" }

TOKEN : {
    < #LETTER: (["a"-"z","A"-"Z"]) >
|    < #DIGIT: ["0"-"9"] >

}

TOKEN : {
    //Propios del programa
    < tBEGIN: "begin" >
|   < tEND: "end" >
|   < tASIGN: ":=" >
|   < tREF: "ref" >
|   < tIS: "is" >
|   < tOF: "of" >
|   < tPROC: "procedure" >
|   < tFUNC: "function" >
|   < tNULL: "null" >
|   < tARRAY: "array" >
|   < tRETURN: "return" >
|   < tEXIT: "exit" >


    //Tipos de datos
|   < tCHAR: "character" >
|   < tBOOL: "boolean" >
|   < tINT: "integer" >
|   < tCHARCONST: "\'" ~["\n"] "\'" >
|   < tINTCONST: (<DIGIT>)+ >
|   < tTRUE: "true" >
|   < tFALSE: "false" >
|   < tSTRING: "\"" ((~["\n", "\""])* ("\"\"")? )* "\""  > {
    // quitamos la doble "" por "
    matchedToken.image = image.toString().replaceAll("\"\"", "\"");
}

    //Operadores
|   <tAND: "and" >
|   <tOR: "or" >
|   <tNOT: "not" >
|   < tPLUS: "+" >
|   < tMINUS: "-" >
|   < tTIMES: "*" >
|   < tDIV: "/" >
|   < tLT: "<" >
|   < tGT: ">" >
|   < tEQ: "=" >
|   < tNE: "/=" >
|   < tLE: "<=" >
|   < tGE: ">=" >
|   < tMOD: "mod" >
|   < tAPAR: "(" >
|   < tCPAR: ")" >
|   < tPC: ";" >
|   < tDP: ":" >
|   < tCOMA: "," >
|   < tRANGE: ".." >
// Built in functions
|   < tSKIPLINE: "skip_line" >
|   < tGET: "get" >
|   < tPUTLINE: "put_line" >
|   < tPUT: "put" >
|   < tINT2CHAR: "int2char" >
|   < tCHAR2INT: "char2int" >

//Condicionales
|   < tIF: "if" >
|   < tELSE: "else" >
|   < tELSIF: "elsif" >
|   < tTHEN: "then" >
|   < tWHILE: "while" >
|   < tLOOP: "loop" >

//Identificadores
|   < tID: ( <LETTER> |"_") (<LETTER> | <DIGIT> | "_")* >
|   < tRESTO: ~[] >
   
}


Token boolconst():
{
    Token bool_const = null;
}
{
    ( bool_const = <tTRUE> | bool_const = <tFALSE>) { return bool_const; }
}

// Devuelve el array con los símbolos de los identificadores con su tipo
// @param ids: lista de identificadores a los que se les va a asignar un tipo
// @param ref: token que indica si el tipo es por referencia
ArrayList<Symbol> tipo_dato(ArrayList<String> ids, boolean isRef):
{
    ArrayList<Symbol> t;
    Token neg1 = null, neg2 = null, min, max;
}
{
    t = tipo_base(ids, isRef){
   	 	return t;
	}
    | <tARRAY> <tAPAR> ( neg1 = <tMINUS>)? min = <tINTCONST> <tRANGE> ( neg2 = <tMINUS>)?  max = <tINTCONST> <tCPAR> <tOF> t = tipo_base(ids, isRef) {
   	 return SemanticFunctions.simbolos_con_tipo(ids, isRef, t, min, max, neg1, neg2);
    }
}


// Devuelve el array con los símbolos de los identificadores con su tipo
// @param ids: lista de identificadores a los que se les va a asignar un tipo
// @param isRef: indica si el tipo es por referencia
ArrayList<Symbol> tipo_base(ArrayList<String> ids, boolean isRef):
{
    Symbol t;
}
{
    (<tCHAR> {t = new SymbolChar("");} | <tBOOL> {t = new SymbolBool("");} | <tINT>{t = new SymbolInt("");} ) {
   	 return SemanticFunctions.ids_simbolos_base(ids, isRef, t);
    }
}


// Devuelve el typevalue con el valor de la constante
// Apila el valor de la constante, y si es un string y se tiene que escribir también genera los WRT
TypeValue tipo_constante(Attributes at, CodeBlock cb):
{
    Token char_const = null;
    Token int_const = null;
    Token bool_const = null;
    Token string_const = null;
	TypeValue tv = null;
}
{
    char_const = <tCHARCONST> {
   	 	tv = new TypeValue(Symbol.Types.CHAR, char_const.image.charAt(1));
		if (Constants.errorFree) {
			if(Constants.comments) cb.addComment("Storing constant character -> " + char_const.image.charAt(1));
			cb.addInst(PCodeInstruction.OpCode.STC, (int)(char)tv.value);
		}
		return tv;
    } | int_const = <tINTCONST> {
		tv = new TypeValue(Symbol.Types.INT, Integer.parseInt(int_const.image));
		if (Constants.errorFree) {
			if(Constants.comments) cb.addComment("Storing constant integer -> " + int_const.image);
			cb.addInst(PCodeInstruction.OpCode.STC, (int)tv.value);
		}
		return tv;
    } | bool_const = boolconst() {
		tv = new TypeValue(Symbol.Types.BOOL, Boolean.parseBoolean(bool_const.image));
		if (Constants.errorFree) {
			if(Constants.comments) cb.addComment("Storing constant boolean -> " + bool_const.image);
			cb.addInst(PCodeInstruction.OpCode.STC, (boolean)tv.value ? 1 : 0);
		}
		return tv;
    } | string_const = <tSTRING> {
		tv = new TypeValue(Symbol.Types.STRING, string_const.image);
		if (Constants.errorFree) {
			// Recorremos el string y lo vamos apilando de final a inicio
			for (int i = 1; i < string_const.image.length() - 1; i++) {
				if(Constants.comments) cb.addComment("Storing constant character -> " + string_const.image.charAt(i));
				cb.addInst(PCodeInstruction.OpCode.STC, (int)(string_const.image.charAt(i)));
				at.cbInst(Symbol.Types.CHAR, cb);
			}
		}
   	 	return tv;
    }
}


//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void Programa(String outputFile) :
{
    SymbolProcedure proc_main = null;
    ArrayList<Symbol> vars = null;
	Label labelMain = new Label(CGUtils.newLabel());;
	CodeBlock cb = new CodeBlock();
	CodeBlock cbProcsFuncs = new CodeBlock();
	CodeBlock insts = new CodeBlock();
}
{
   try {
		proc_main = cabecera_procedimiento(labelMain) {
			SemanticFunctions.insertSymbol(st, proc_main);
			st.setMainProc(proc_main.name);
			// generar etiqueta de procmain	
			if(Constants.comments) cb.addComment("Entrada al programa");
			cb.addInst(PCodeInstruction.OpCode.ENP, labelMain.toString());
		}
		( vars = declaracion_variables() )? {
			if (vars != null) {
				for (Symbol var : vars) {
					SemanticFunctions.insertSymbol(st, var);
				}
				
			} else {
				vars = new ArrayList<Symbol>();
			}
			if(Constants.verbose) System.out.println("Nuevo símbolo: " + st.toString());
		}
		( cbProcsFuncs = declaracion_procs_funcs() {
			cb.addBlock(cbProcsFuncs);
		} )?
		<tBEGIN>
		{cb.addLabel(labelMain.toString() + ":");}
		( insts = instruccion(proc_main) {
			cb.addBlock(insts);
		} )*
		<tEND>
		<tPC>
		< EOF > { 
			if (Constants.errorFree) {
				try {
					cb.addInst(PCodeInstruction.OpCode.LVP);
					if (Constants.xmlOutput) cb.encloseXMLTags("ProcedimientoPrincipal");

					BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));
					writer.write(cb.toString());
					writer.close();
					System.out.println("Generado código en " + outputFile);
				} catch (Exception e) {
					System.out.println("Error escribiendo en " + outputFile);
				}				
				
			} else System.err.println("***** No se ha generado código por problemas detectados *****");
			
		}
    } catch (ParseException e) {
		System.err.println("SYNTAX_ERROR: " + e.getMessage());
		Constants.errorFree = false;


		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
    }

}


ArrayList<Symbol> declaracion_variables() :
{
    ArrayList<Symbol> vars = new ArrayList<Symbol>();
    ArrayList<Symbol> var_list = null;
}
{
    ( var_list = declaracion_var() {
   	 	for (Symbol var: var_list) vars.add(var);
    } )+ {
   	 	return vars;
    }
}
    

ArrayList<Symbol> declaracion_var() :
{
    ArrayList<String> ids;
    ArrayList<Symbol> vars;
}
{
    try {
		// tipo_dato devuelve el símbolo
		ids = lista_ids() <tDP> vars = tipo_dato(ids, false) <tPC> {
			return vars;
		}
    } catch (ParseException e) {
		System.err.println("SYNTAX_ERROR: " + e.getMessage());
		Constants.errorFree = false;


		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
		return new ArrayList<Symbol>();
    }
}


CodeBlock declaracion_procs_funcs() :
{
	CodeBlock cb = new CodeBlock();
	CodeBlock cbInternal = new CodeBlock();
}
{
    ( cbInternal = declaracion_proc() {
		//System.out.println("CodeBlock reconocido -> " + cbInternal.toString());
		cb.addBlock(cbInternal);
	} | cbInternal = declaracion_func() {
		//System.out.println("CodeBlock reconocido -> " + cbInternal.toString());
		cb.addBlock(cbInternal);
	} )+ {
		return cb;
	
	}
}


// Reconoce la declaración de un procedimiento
// Inserta el símbolo del procedimiento en la tabla de símbolos
// Inserta bloque en la tabla de símbolos
// Inserta los parámetros y variables en la tabla de símbolos
CodeBlock declaracion_proc():
{
    SymbolProcedure proc = null;
    ArrayList<Symbol> vars = null;
	CodeBlock cb = new CodeBlock();
	Label labelProc = new Label(CGUtils.newLabel());
	Label labelProcInternal = new Label(CGUtils.newLabel());
	CodeBlock cbProcsFuncs = new CodeBlock();
	CodeBlock insts = new CodeBlock();
}
{
    try {
		proc = cabecera_procedimiento(labelProc) {
			SemanticFunctions.newProcBlock(st, proc);
			
			if (Constants.errorFree) {
				if(Constants.comments) cb.addComment("Leyendo parámetros del procedimiento");
				// necesitas calcular la direccion en frames donde almacenar cada valor, con arrays como parametros intercalados
				// no sabrás donde dejar cada parametro si no tienes la referencia asbsoluta;
				cb.addLabel(labelProc.toString() + ":");
				int dirBaseParametro = st.getDirBase()-1;
				// Los parámetros vienen dados en orden inverso
				if (proc.parList != null) {
					for (int i=proc.parList.size()-1; i>=0; i--) {
						Symbol parameteri = proc.parList.get(i);
						if(Constants.comments) cb.addComment("Leyendo parámetro " + parameteri.name);
						if (parameteri.type == Symbol.Types.ARRAY && !(parameteri.parClass == Symbol.ParameterClass.REF)) {
							SymbolArray sarr = (SymbolArray)parameteri;
							for (int j=sarr.maxInd; j>=sarr.minInd; j--) {
								cb.addInst(PCodeInstruction.OpCode.SRF, 0, dirBaseParametro);
								cb.addInst(PCodeInstruction.OpCode.ASGI);
								dirBaseParametro--;
							}
						} else {
							cb.addInst(PCodeInstruction.OpCode.SRF, 0, dirBaseParametro);
							cb.addInst(PCodeInstruction.OpCode.ASGI);
							dirBaseParametro--;
						}
					}
				}
				

				// JMP para saltar al código del procc/func actual, sino se ejecutaría el código
				// de los procedimientos y funciones declarados internamente, que es lo que se encuentra
				// debajo de la declaración de la recuperación de los valores de los parámetros
				cb.addInst(PCodeInstruction.OpCode.JMP, labelProcInternal.toString());
			}
		}
		( vars = declaracion_variables() )? {
			if (vars != null) {
				for (Symbol var : vars) SemanticFunctions.insertSymbol(st, var);
			} else {
				vars = new ArrayList<Symbol>();
			}
		}
		
		( cbProcsFuncs = declaracion_procs_funcs() {
			cb.addBlock(cbProcsFuncs);
		})?
		<tBEGIN>
		{cb.addLabel(labelProcInternal.toString() + ":");}
		( insts = instruccion(proc) {
			cb.addBlock(insts);
		})+
		<tEND>
		<tPC>
		{	
			
			if(Constants.verbose) System.out.println("Procedimiento reconocido: " + st.toString());
			st.removeBlock();
			if (Constants.errorFree)	{
				cb.addInst(PCodeInstruction.OpCode.CSF);
				if (Constants.xmlOutput) cb.encloseXMLTags("Procedimiento_" + proc.name);
			}
			return cb;
		}
    } catch (ParseException e) {
		System.err.println("SYNTAX ERROR: " + e.getMessage());
		Constants.errorFree = false;
		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
		return cb;
    }
}


// Reconoce la declaración de una función
// Inserta el símbolo de la función en la tabla de símbolos
// Inserta bloque en la tabla de símbolos
// Inserta los parámetros y variables en la tabla de símbolos
CodeBlock declaracion_func():
{
    ArrayList<Symbol> vars = new ArrayList<Symbol>();
    SymbolFunction func = null;
	CodeBlock cb = new CodeBlock();
	Label labelFunc = new Label(CGUtils.newLabel());
	Label labelFuncInternal = new Label(CGUtils.newLabel());
	CodeBlock cbProcsFuncs = new CodeBlock();
	CodeBlock insts = new CodeBlock();
}
{
    
    try {
		func = cabecera_funcion(labelFunc) {
			SemanticFunctions.newFuncBlock(st, func);
			if (Constants.errorFree) {
				if(Constants.comments) cb.addComment("Funcion " + func.name);
				
				if (Constants.xmlOutput) cb.encloseXMLTags("Función " + func.name);

				if(Constants.comments) cb.addComment("Leyendo parámetros de la función");
				cb.addLabel(labelFunc.toString() + ":");
				// necesitas calcular la direccion en frames donde almacenar cada valor, con arrays como parametros intercalados
				// no sabrás donde dejar cada parametro si no tienes la referencia asbsoluta;
				int dirBaseParametro = st.getDirBase()-1;

				// Los parámetros vienen dados en orden inverso
				if (func.parList != null) {
					for (int i=func.parList.size()-1; i>=0; i--) {
						Symbol parameteri = func.parList.get(i);
						cb.addComment("Leyendo parámetro " + parameteri.name);
						if (parameteri.type == Symbol.Types.ARRAY && !(parameteri.parClass == Symbol.ParameterClass.REF)) {
							SymbolArray sarr = (SymbolArray)parameteri;
							for (int j=sarr.maxInd; j>=sarr.minInd; j--) {
								cb.addInst(PCodeInstruction.OpCode.SRF, 0, dirBaseParametro);
								cb.addInst(PCodeInstruction.OpCode.ASGI);
								dirBaseParametro--;
							}
						} else {
							cb.addInst(PCodeInstruction.OpCode.SRF, 0, dirBaseParametro);
							cb.addInst(PCodeInstruction.OpCode.ASGI);
							dirBaseParametro--;
						}
					}
				}
				cb.addInst(PCodeInstruction.OpCode.JMP, labelFuncInternal.toString());
			}
		}
		( vars = declaracion_variables() )? {
			if (vars != null) for (Symbol var : vars) SemanticFunctions.insertSymbol(st, var);
		}
		( cbProcsFuncs = declaracion_procs_funcs() {
			if(Constants.comments) cb.addComment("Procedimientos y funciones internos");
			cb.addBlock(cbProcsFuncs);
		})?
		<tBEGIN>{cb.addLabel(labelFuncInternal.toString() + ":");}
		( insts = instruccion(func) {
			cb.addBlock(insts);
		})+ // Pasamos el símbolo de la función para que se pueda comprobar el return
		<tEND>
		<tPC>
		{
			if(Constants.verbose) System.out.println("Función reconocida: " + st.toString());
			st.removeBlock();
			cb.encloseXMLTags(func.name);
			return cb;
		}
    } catch (ParseException e) {
		System.err.println("SYNTAX_ERROR: " + e.getMessage());
		Constants.errorFree = false;


		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
		return cb;
    }
}


ArrayList<Symbol> declaracion_param() :
{
    ArrayList<String> ids;
    ArrayList<Symbol> ids_con_tipo;
    Token ref = null;
}
{
    ids = lista_ids() <tDP> ( ref=<tREF> )? ids_con_tipo = tipo_dato(ids, ref != null)
    {
   	 	return ids_con_tipo;
    }
}


// Devuelve la lista de identificadores reconocidos
ArrayList<String> lista_ids() :
{
    ArrayList<String> ids = new ArrayList<String>();
    ArrayList<String> resto_ids = null;
    Token id;
}
{
    ( LOOKAHEAD(2) id = <tID> <tCOMA> resto_ids = lista_ids()
|    id = <tID>) {
		ids.add(id.image);
		if (resto_ids != null) {
			for (String sid : resto_ids) ids.add(sid);
		}
		return ids;
    }
}


// Devuelve el símbolo del procedimiento con los parámetros
SymbolProcedure cabecera_procedimiento(Label label):
{
    Token id_proc;
    ArrayList<Symbol> proc_params = null;
}
{
    <tPROC> id_proc = <tID> ( proc_params = parametros_formales() )? <tIS>
    {
   	 	return new SymbolProcedure(id_proc.image, proc_params, label.toString());
    }
}


// Devuelve el símbolo de la función con los parámetros
SymbolFunction cabecera_funcion(Label label):
{
    Token id_func;
    ArrayList<Symbol> func_params = null;
    ArrayList<Symbol> returnType = null;
    
}
{
    <tFUNC> id_func = <tID> ( func_params = parametros_formales() )? <tRETURN> returnType = tipo_base(new ArrayList<String>(Arrays.asList("returnType")), false) <tIS> {
		if (returnType.get(0).type != Symbol.Types.INT && returnType.get(0).type != Symbol.Types.BOOL && returnType.get(0).type != Symbol.Types.CHAR) {
			ArrayList<Symbol.Types> expectedTypes = new ArrayList<Symbol.Types>();
			expectedTypes.add(Symbol.Types.INT);
			expectedTypes.add(Symbol.Types.CHAR);
			expectedTypes.add(Symbol.Types.BOOL);
			UnexpectedTypeException.getMessage(expectedTypes, returnType.get(0).type, id_func.beginLine, id_func.beginColumn);
		}
   	 	return new SymbolFunction(id_func.image, func_params, returnType.get(0).type, label.toString());
    }
}


// Devuelve el array con los símbolos de los identificadores con su tipo
ArrayList<Symbol> parametros_formales():
{
    ArrayList<Symbol> params = new ArrayList<Symbol>();
    ArrayList<Symbol> ps, resto_p;
}
{
    try {
		( <tAPAR>    ps = declaracion_param() {
				for (Symbol p :  ps) params.add(p);
			}
		
			resto_p = lista_parametros_formales() {
				for (Symbol p :  resto_p) params.add(p);
			} <tCPAR> // con parámetros
		| "" ) // sin parámetros (épsilon)
    } catch (ParseException e) {
		System.err.println("SYNTAX_ERROR: " + e.getMessage());
		Constants.errorFree = false;


		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
    }
    { return params; }
}


ArrayList<Symbol> lista_parametros_formales():
{
    ArrayList<Symbol> params = new ArrayList<Symbol>();
    ArrayList<Symbol> ps, resto_p;
}
{
    (<tPC> ps = declaracion_param(){
		for (Symbol p :  ps) params.add(p);
	}
   	resto_p = lista_parametros_formales() {
   		for (Symbol p :  resto_p) params.add(p);
   	}
    ) { return params; }
    | { return params; }
}


//where es el símbolo de la función o el procedimiento en la que se encuentra la instrucción
//Usado para comprobar que el return tiene el tipo correcto y no hay return en procedimientos
CodeBlock instruccion(Symbol where) :
{
	CodeBlock cb = new CodeBlock();
}
{
    try {
		(  cb = inst_leer()
		|  cb = inst_skipline()
		|  cb = inst_escribir()
		|  cb = inst_escribir_linea()
		|  cb = inst_invocacion_o_asignacion()
		|  cb = inst_if(where)
		|  cb = inst_while(where)
		|  cb = inst_return(where)
		|  cb = inst_exit()
		|  <tNULL>) <tPC> {
			return cb;
		}
    } catch (ParseException e) {
		System.err.println("SYNTAX_ERROR: " + e.getMessage());
		Constants.errorFree = false;
		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
		return cb;
    }

}


CodeBlock inst_leer() :
{
    ArrayList<TypeValue> exps = null;
	Token get = null;	// Token usado para que en caso de error se pueda mostrar la línea y columna
	CodeBlock cb = new CodeBlock();
	Attributes attrs = new Attributes(Attributes.State.EnInvocacion, Attributes.DequeueMethod.Peek, PCodeInstruction.OpCode.RD);
	attrs.setQueue(Symbol.ParameterClass.REF);
}
{
    get = <tGET> <tAPAR> exps = lista_una_o_mas_exps(attrs, cb) <tCPAR> {
		SemanticFunctions.inst_leer(exps, get);
		if(Constants.verbose) System.out.println("Encontrada instrucción get correcta");
		if(Constants.errorFree && Constants.xmlOutput) cb.encloseXMLTags("get");
		return cb;
    }
}


CodeBlock inst_escribir() :
{
    ArrayList<TypeValue> exps = new ArrayList<TypeValue>();
	Token put = null;
	CodeBlock cb = new CodeBlock();
	Attributes attrs = new Attributes(Attributes.State.EnInvocacion, Attributes.DequeueMethod.Peek, PCodeInstruction.OpCode.WRT);
	attrs.setQueue(Symbol.ParameterClass.VAL);
}
{
    put = <tPUT> <tAPAR> exps = lista_una_o_mas_exps(attrs, cb) <tCPAR> {
		SemanticFunctions.inst_escribir(exps, put.beginLine, put.beginColumn);
		if(Constants.verbose) System.out.println("Encontrada instrucción put correcta");
		if(Constants.errorFree && Constants.xmlOutput) cb.encloseXMLTags("put");
		return cb;
    }
}


CodeBlock inst_escribir_linea() :
{
    ArrayList<TypeValue> exps = new ArrayList<TypeValue>();
	Token put = null;
	CodeBlock cb = new CodeBlock();
	Attributes attrs = new Attributes(Attributes.State.EnInvocacion, Attributes.DequeueMethod.Peek, PCodeInstruction.OpCode.WRT);
	attrs.setQueue(Symbol.ParameterClass.VAL);
}
{
    put = <tPUTLINE> (<tAPAR> exps = lista_una_o_mas_exps(attrs, cb)    <tCPAR>)? {
		SemanticFunctions.inst_escribir(exps, put.beginLine, put.beginColumn);
		if(Constants.verbose) System.out.println("Encontrada instrucción put_line correcta");
		if	(Constants.errorFree) {
			// Añadir un salto de línea al final en la generación de código
			if(Constants.comments) cb.addComment("Salto de línea");

			cb.addInst(PCodeInstruction.OpCode.STC, 13); // CR
			cb.addInst(PCodeInstruction.OpCode.WRT, 0);
			
			cb.addInst(PCodeInstruction.OpCode.STC, 10); // LF
			cb.addInst(PCodeInstruction.OpCode.WRT, 0);
			
			if (Constants.xmlOutput) cb.encloseXMLTags("put_line");
		} 
		return cb;
	
    }
}


CodeBlock inst_invocacion_o_asignacion() :
{
	TypeValue p = null, exp = null;
	Token asign = null;
	CodeBlock cb = new CodeBlock();
	Attributes attrs = new Attributes(Attributes.State.Normal, Attributes.DequeueMethod.Remove);
	Attributes attrsAsign = new Attributes(Attributes.State.EnAsignacion, Attributes.DequeueMethod.Peek);
}
{
	// si ha sido invocación sin params, no habrá nada en el tope de la pila
	// si es asignación, en la pila estará la @ de la variable a asignar y encima el resultado de evaluar la expresión -> haces un asg
	p = invoc_o_asign_primario(attrsAsign, cb) (asign = <tASIGN> exp = expresion(attrs, cb))? {
		SemanticFunctions.inst_invocacion_o_asignacion(p, exp, asign);
		if(Constants.verbose) {
			if (asign != null) System.out.println("Invocación correcta en línea: " + String.valueOf(asign.beginLine));
			else System.out.println("Invocación correcta");
		}
		if (Constants.errorFree && asign != null) cb.addInst(PCodeInstruction.OpCode.ASG);
		return cb;
	}
}


CodeBlock inst_if(Symbol sf) :
{
	TypeValue expif = null, expelsif = null;
	Token tif = null, elsif = null;
	CodeBlock cb = new CodeBlock();
	CodeBlock cbInst = null;
	Attributes attrs = new Attributes(Attributes.State.Normal, Attributes.DequeueMethod.Remove);
	boolean condicionSiempreTrue = false;
	Label nextLabel = new Label(CGUtils.newLabel("elseif"));
	Label endLabel = new Label(CGUtils.newLabel("endIf"));
	Token telse = null;
}
{
	
	// if (exp) insts		-- (exp) | jmf  elsif0 | insts | jmp labelFinIf
	// else if (exp) insts  -- jmt  trueElsif0 (... jmt trueElsifx)
	// else insts			-- insts
	// end if;
	//						-- elsif0: (exp) | jmf elsifx | insts | jmp labelFinIf
	//						-- elsifx(else): insts
    // debe haber por lo menos una instrucción en el bloque condicional (null en casos donde no se haga nada)
    tif = <tIF> expif = expresion(attrs, cb) <tTHEN> {
		// expif es un TypeValue, por lo que si tiene valor no generaremos todo el código
		SemanticFunctions.inst_if(expif, tif);
		if (Constants.errorFree) {
			if(expif.value != null) {
				if ((boolean)expif.value) condicionSiempreTrue = true;
				else if(Constants.comments) cb.addComment("Condición if siempre FALSA, no se ha generado código");
				//! LA EXPRESIÓN YA ESTÁ APILADA EN LA PILA, HAY QUE QUITARLA
				cb.addInst(PCodeInstruction.OpCode.POP);
			}
			
			if (expif.value == null) {
				// Saltas si la evaluación de la expresión es falsa
				cb.addInst(PCodeInstruction.OpCode.JMF, nextLabel.toString());
			}
			
		}
	} (cbInst = instruccion(sf) { if (expif.value == null || condicionSiempreTrue) cb.addBlock(cbInst); } )+ {
		if (Constants.errorFree && (expif.value == null || condicionSiempreTrue)) {
			// generas el código del else if !condicionSimpreTrue y si expif.value == null || expif.value == true
			cb.addInst(PCodeInstruction.OpCode.JMP, endLabel.toString());
		}
	}
	
	(elsif = <tELSIF>{
		cb.addLabel(nextLabel.toString() + ":");
		nextLabel = new Label(CGUtils.newLabel("elseif"));
	} expelsif = expresion(attrs, cb) <tTHEN>  {
		SemanticFunctions.inst_if(expelsif, elsif);
		if (!condicionSiempreTrue && Constants.errorFree) {
			if(expelsif.value != null) {
				if ((boolean)expelsif.value) condicionSiempreTrue = true;
				else if(Constants.comments) cb.addComment("Condición if siempre FALSA, no se ha generado código");
				cb.addInst(PCodeInstruction.OpCode.POP);
			}
			
			if (expelsif.value == null) {
				// Si la condición no tiene un valor constante o si ese valor es verdadero se genera código
				cb.addInst(PCodeInstruction.OpCode.JMF, nextLabel.toString());
			}
			System.err.println("OK expresion");
		}
	} ( cbInst = instruccion(sf) { if (expelsif.value == null || condicionSiempreTrue) cb.addBlock(cbInst); })+ {
		if (Constants.errorFree) {
			if (expelsif.value == null || condicionSiempreTrue) {
				cb.addInst(PCodeInstruction.OpCode.JMP, endLabel.toString());
			}
		}
	} )*
    ( telse = <tELSE> { cb.addLabel(nextLabel.toString() + ":"); } ( cbInst = instruccion(sf) { cb.addBlock(cbInst); } )+)?
    <tEND> <tIF>{ 
		if (telse != null || elsif != null) cb.addLabel(endLabel.toString() + ":");
		else {
			// elimina instruccion anterior
			cb.removeLastInst();
			// añade label de nextLabel
			cb.addLabel(nextLabel.toString() + ":");
		}
		if(Constants.verbose) System.out.println("Encontrada instrucción if correcta en línea: " + String.valueOf(tif.beginLine));
		if(Constants.errorFree && Constants.xmlOutput) cb.encloseXMLTags("if");
		return cb;
	}
}


CodeBlock inst_while(Symbol sf) :
{
	TypeValue exp = null;
	Token twhile = null;
	CodeBlock cb = new CodeBlock();
	Attributes attrs = new Attributes(Attributes.State.Normal, Attributes.DequeueMethod.Remove);
	Label whileLabel = new Label(CGUtils.newLabel("while"));
	Label endLabel = new Label(CGUtils.newLabel("endWhile"));
	CodeBlock cbInst = null;
}
{
    twhile = <tWHILE> {cb.addLabel(whileLabel.toString() + ":");} exp = expresion(attrs, cb) {
		// exp | jmf end_if
		cb.addInst(PCodeInstruction.OpCode.JMF, endLabel.toString());
	} <tLOOP> (cbInst = instruccion(sf) { cb.addBlock(cbInst); } )+ <tEND> <tLOOP>  {
		SemanticFunctions.inst_while(exp, twhile);
		if(Constants.verbose) System.out.println("Encontrada instrucción while correcta en línea: " + String.valueOf(twhile.beginLine));
		if(Constants.errorFree){
			// Saltamos al principio del bucle
			cb.addInst(PCodeInstruction.OpCode.JMP, whileLabel.toString());
			cb.addLabel(endLabel.toString() + ":");
			cb.encloseXMLTags("while");
		}
		return cb; 
	}
}


CodeBlock inst_return(Symbol sf) :
{
	TypeValue exp = null;
	Token treturn = null;
	CodeBlock cb = new CodeBlock();
	Attributes attrs = new Attributes(Attributes.State.Normal, Attributes.DequeueMethod.Remove);
}
{
	treturn = <tRETURN> exp = expresion(attrs, cb) {
		SemanticFunctions.inst_return(exp, sf, treturn);
		if(Constants.verbose) System.out.println("Encontrada instrucción return correcta en línea: " + String.valueOf(treturn.beginLine));
		if (Constants.errorFree) cb.addInst(PCodeInstruction.OpCode.CSF);
		return cb;
	}
}


CodeBlock inst_exit() :
{
	Token texit = null;
	CodeBlock cb = new CodeBlock();
	Attributes attrs = new Attributes(Attributes.State.Normal, Attributes.DequeueMethod.Remove);
}
{
	texit = <tEXIT> {
		if(Constants.verbose) System.out.println("Encontrada instrucción exit correcta en línea: " + String.valueOf(texit.beginLine));
		if(Constants.errorFree) cb.addInst(PCodeInstruction.OpCode.LVP);
		if(Constants.xmlOutput) cb.encloseXMLTags("exit");
		return cb;
	}
}


CodeBlock inst_skipline() : 
{
	CodeBlock cb = new CodeBlock();
	Attributes attrs = new Attributes(Attributes.State.Normal, Attributes.DequeueMethod.Remove);
	Label initLabel = new Label(CGUtils.newLabel("skipline"));
}
{
	//skip line salta caracteres de la entrada hasta que logra leer y saltar un new line
	<tSKIPLINE> {
		if (Constants.errorFree) {
			// cte '\n' para comparar en el bucle
			cb.addLabel(initLabel.toString() + ":");
			cb.addInst(PCodeInstruction.OpCode.STC, 10);
			// bucle
			if(Constants.comments) cb.addComment("bloque do-while skipline");
			// comparación con la cte
			cb.addInst(PCodeInstruction.OpCode.SRF, 0, st.getDirBase());
			cb.addInst(PCodeInstruction.OpCode.RD, 0);
			cb.addInst(PCodeInstruction.OpCode.SRF, 0, st.getDirBase());
			cb.addInst(PCodeInstruction.OpCode.DRF);
			cb.addInst(PCodeInstruction.OpCode.EQ);

			cb.addInst(PCodeInstruction.OpCode.JMF, initLabel.toString());
		}
		return cb;
	}
}


TypeValue expresion(Attributes at, CodeBlock cb):
{
    TypeValue prel = null, srel = null;
    Token op = null;
	TypeValue result = null;

	// Con Normal no se va a usar la cola, da igual el método de desencolado
	Attributes atLocal = new Attributes(Attributes.State.Normal, Attributes.DequeueMethod.Peek);
	
	// Cambiamos el modo de consumición de la cola a peek para que en caso de que se esté en una invocación y se tenga una expresión(a+b o similar) que tenga que dejar un
	// valor en la pila, no se consuma el parámetro, además si se tiene una expresión de este tipo significa que el parámetro es por valor, por lo que no importa que se haga peek
	// Si por el contrario la expresión es un identificador o una constante, se consumirá el parámetro de la pila que puede ser una referencia
	// y al volver de la invocación se consumirá el valor de la pila que se ha dejado en la invocación si el método anterior para consumir la pila era remove
	Attributes atPeek = new Attributes(at.state, Attributes.DequeueMethod.Peek, at.ioInst);
	if (at.paramIsRefInvocacion != null) {
		atPeek.paramIsRefInvocacion = new PriorityQueue<Boolean>(at.paramIsRefInvocacion);
	} else {
		atPeek.setQueue(Symbol.ParameterClass.REF);
	}
	// "and" y "or" son asociativos a la izqda. pero mezclados, no está definida su asociatividad, por lo que hay que usar paréntesis que definan la prioridad de las operaciones.
}
{
	//f(a,b,c)
	//    foo(a and b) or (c and d))
	prel = relacion(atPeek, cb) ((op = <tAND> srel = relacion(atLocal, cb) {
		result = SemanticFunctions.expresion(srel, result, op, tAND, tOR);
		if(Constants.verbose) System.out.println("Encontrada expresión AND correcta");
		if(Constants.errorFree){
			cb.addInst(PCodeInstruction.OpCode.AND);
		}
	})+
	| (op = <tOR> srel = relacion(atLocal, cb) {
		result = SemanticFunctions.expresion(srel, result, op, tAND, tOR);
		if(Constants.verbose) System.out.println("Encontrada expresión OR correcta");
		if(Constants.errorFree){
			cb.addInst(PCodeInstruction.OpCode.OR);
		}
		
	})+)? {
	 	return SemanticFunctions.expresion(prel, result, op, tAND, tOR);
    }
}


TypeValue relacion(Attributes at, CodeBlock cb):
{
    TypeValue exp1 = null, exp2 = null;    
    Token op = null;
	Attributes atLocal = new Attributes(Attributes.State.Normal, Attributes.DequeueMethod.Remove);
}
{
	exp1 = expresion_simple(at, cb)
	( op = operador_relacional() exp2 = expresion_simple(atLocal, cb) )? {
		if(Constants.verbose) System.out.println("Encontrada relación correcta");
		if(Constants.errorFree){
			if (op != null) {
				if(Constants.comments) cb.addComment("Relación " + op.image);
				switch(op.kind) {
					case tEQ: cb.addInst(PCodeInstruction.OpCode.EQ); break;
					case tNE: cb.addInst(PCodeInstruction.OpCode.NEQ); break;
					case tLT: cb.addInst(PCodeInstruction.OpCode.LT); break;
					case tLE: cb.addInst(PCodeInstruction.OpCode.LTE); break;
					case tGT: cb.addInst(PCodeInstruction.OpCode.GT); break;
					case tGE: cb.addInst(PCodeInstruction.OpCode.GTE); break;
				}
			}
			
		}
		return SemanticFunctions.relacion(exp1, op, exp2, tEQ, tNE, tLT, tLE, tGT, tGE);
    }
}


Token operador_relacional():
{
    Token t;
}
{
    (t = <tEQ> | t = <tNE> | t = <tLT> | t = <tLE> | t = <tGT> | t = <tGE>) { return t; }
}


TypeValue expresion_simple(Attributes at, CodeBlock cb):
{
    TypeValue term = null, term_resultante = null;
    Token op = null, ops = null;
	Attributes atLocal = new Attributes(Attributes.State.Normal, Attributes.DequeueMethod.Remove);
}
{
	( ops = <tPLUS> | ops = <tMINUS> )? term = termino(at, cb) {
		if (ops != null && ops.kind == tMINUS) cb.addInst(PCodeInstruction.OpCode.NGI);
	} (( op = <tPLUS> | op = <tMINUS> ) term_resultante = una_o_mas_expresiones_simples(atLocal, cb))? {
		TypeValue tv = SemanticFunctions.expresion_simple(ops, term, op, term_resultante, tPLUS, tMINUS);
		if (op != null && Constants.errorFree) {
			if (op.kind == tMINUS) {
				cb.addInst(PCodeInstruction.OpCode.SBT);
			} else {
				cb.addInst(PCodeInstruction.OpCode.PLUS);
			}
		}
		return tv;
    }
}


TypeValue una_o_mas_expresiones_simples(Attributes at, CodeBlock cb):
{
    TypeValue term = null, term_resultante = null;
    Token op = null, ops = null;
}
{
    term = termino(at, cb) (( op = <tPLUS> | op = <tMINUS> ) term_resultante = una_o_mas_expresiones_simples(at, cb))? {
		TypeValue tv = SemanticFunctions.una_o_mas_expresiones_simples(term, op, term_resultante, tPLUS, tMINUS);
		if (op != null && Constants.errorFree) {
			if (op.kind == tMINUS) {
				cb.addInst(PCodeInstruction.OpCode.SBT);
			} else {
				cb.addInst(PCodeInstruction.OpCode.PLUS);
			}
		}
   	 	return tv;
    }
}


TypeValue termino(Attributes at, CodeBlock cb):
{
    TypeValue fact = null, fact_resultante = null;
    Token op = null;
	Attributes atLocal = new Attributes(Attributes.State.Normal, Attributes.DequeueMethod.Remove);
}
{
    fact = factor(at, cb) ( op = operador_multiplicativo() fact_resultante = lista_una_o_mas_terminos(atLocal, cb, op) )? {
		TypeValue tv = SemanticFunctions.termino(fact, op, fact_resultante, tTIMES, tDIV, tMOD);
		if(Constants.errorFree && op != null && Constants.comments) cb.addComment("Término " + op.image);
		return tv;
    }
}


TypeValue lista_una_o_mas_terminos(Attributes at, CodeBlock cb, Token opAnterior):
{
    TypeValue fact = null, fact_resultante = null;
    Token op = null;
}
{
    fact = factor(at, cb) { 
		if(Constants.errorFree){
			if(Constants.comments) cb.addComment("Término " + opAnterior.image);
			switch(opAnterior.kind) {
				case tTIMES: cb.addInst(PCodeInstruction.OpCode.TMS); break;
				case tDIV: cb.addInst(PCodeInstruction.OpCode.DIV); break;
				case tMOD: cb.addInst(PCodeInstruction.OpCode.MOD); break;
			}
		}
	 } ( op = operador_multiplicativo() fact_resultante = lista_una_o_mas_terminos(at, cb, op))? {
		return SemanticFunctions.termino(fact, op, fact_resultante, tTIMES, tDIV, tMOD);
    }
}


Token operador_multiplicativo() :
{
    Token t;
}
{
    (t = <tTIMES> | t = <tDIV> | t = <tMOD>) { return t; }
}


TypeValue factor(Attributes at, CodeBlock cb):
{
    TypeValue p = null;
	Token not = null;
	Attributes atLocal = new Attributes(Attributes.State.Normal, Attributes.DequeueMethod.Remove);
}
{
    p = primario(at, cb) {
   	 return p;
    }
    | not = <tNOT> p = primario(atLocal, cb) {
		TypeValue tv = SemanticFunctions.not_primario(p, not.beginLine, not.beginColumn);
		if (Constants.errorFree) {
			if(Constants.comments) cb.addComment("Negación lógica");
			cb.addInst(PCodeInstruction.OpCode.NGB);
		}

		return tv;
    }
}


TypeValue primario(Attributes at, CodeBlock cb) :
{
    TypeValue exp = null;
    Token id = null, fnToken = null;
}
{
	<tAPAR> exp = expresion(at, cb) <tCPAR> { return exp; } // new Attributes 
|    fnToken = <tINT2CHAR> <tAPAR> exp = expresion(at, cb) <tCPAR> {
    // System.out.println(exp.value);
    if (exp.type != Symbol.Types.INT) UnexpectedTypeException.getMessage(Symbol.Types.INT, exp.type, fnToken.beginLine, fnToken.beginColumn);
	// en gen. de código comprobar que el valor es mayor que 0 ?? 
	TypeValue tv = new TypeValue(Symbol.Types.CHAR, exp.value);
	return tv;
}	
|    fnToken = <tCHAR2INT> <tAPAR> exp = expresion(at, cb) <tCPAR> {
	if (exp.type != Symbol.Types.CHAR) UnexpectedTypeException.getMessage(Symbol.Types.CHAR, exp.type, fnToken.beginLine, fnToken.beginColumn);
	return new TypeValue(Symbol.Types.INT, null);

}
|    exp = invoc_o_asign_primario(at, cb) {return exp;}
|    exp = tipo_constante(at, cb) { return exp; }
}


// Reconoce a un invocado o a un asignado
TypeValue invoc_o_asign_primario(Attributes at, CodeBlock cb):
{
	TypeValue exp = null;
    Token id = null;
	ArrayList<TypeValue> exps = null;
	Attributes attrsLocal = new Attributes(Attributes.State.EnInvocacion, Attributes.DequeueMethod.Remove); 
	Symbol s = null;
}
{
	LOOKAHEAD(2) id = <tID> <tAPAR> {
		// distinguir si id es func/proc o array f(a+b)
		s = st.getSymbol(id.image);
		if (s.type == Symbol.Types.FUNCTION) attrsLocal.setQueue(((SymbolFunction) s).parList);
		else if (s.type == Symbol.Types.PROCEDURE) attrsLocal.setQueue(((SymbolProcedure) s).parList);
		else attrsLocal.setQueue(Symbol.ParameterClass.VAL);
		
	} exps = lista_una_o_mas_exps(attrsLocal, cb) <tCPAR> /*invoc. func. o comp. array*/ {
		TypeValue semanticResult = SemanticFunctions.invoc_func_o_comp_array(id, exps, st);
		// mirar ts con id.img para obtener el Symbol.dir
		// si id es func/proc -> apilar + osf
		// si id es comp. vector
		switch (s.type) {
			case ARRAY:
				boolean expectsARefAsign = at.state == Attributes.State.EnAsignacion;
				boolean expectsARefInv = !expectsARefAsign && at.state == Attributes.State.EnInvocacion && at.consumeQueue();
				
				// top_stack = ind
                // top_stack -> ind - minInd
				SymbolArray sarr = (SymbolArray)s;
                cb.addInst(PCodeInstruction.OpCode.STC, sarr.minInd > 0 ? sarr.minInd : -sarr.minInd);
				if(sarr.minInd < 0) cb.addInst(PCodeInstruction.OpCode.NGI);
                cb.addInst(PCodeInstruction.OpCode.SBT);

				if (expectsARefInv || expectsARefAsign) {
					// Si se espera una referencia
					if (s.parClass == Symbol.ParameterClass.REF) {
						// si id es una ref -> srf + drf
						if(Constants.comments) cb.addComment("Vector pasado a parámetro por referencia");
						cb.addInst(PCodeInstruction.OpCode.SRF, st.level-s.nivel, s.dir);
						cb.addInst(PCodeInstruction.OpCode.DRF);
						cb.addInst(PCodeInstruction.OpCode.PLUS);	// Ya tendrás apilado el índice del vector
					} else {
						// si no -> srf
						if(Constants.comments) cb.addComment("Vector pasado a parámetro por valor");
						cb.addInst(PCodeInstruction.OpCode.SRF, st.level-s.nivel, s.dir);
						cb.addInst(PCodeInstruction.OpCode.PLUS);
					}
				} else {
					// si se espera un valor
					if ( s.parClass == Symbol.ParameterClass.REF) {
						// si id es una ref -> srf + drf + drf
						if(Constants.comments) cb.addComment("Componente de vector pasada por referencia");
						cb.addInst(PCodeInstruction.OpCode.SRF, st.level-s.nivel, s.dir);
						cb.addInst(PCodeInstruction.OpCode.DRF);
						cb.addInst(PCodeInstruction.OpCode.PLUS);
						cb.addInst(PCodeInstruction.OpCode.DRF);
					} else { 
						// si no -> srf + drf
						if(Constants.comments) cb.addComment("Componente de vector pasada por valor");
						cb.addInst(PCodeInstruction.OpCode.SRF, st.level-s.nivel, s.dir);
						cb.addInst(PCodeInstruction.OpCode.PLUS);
						cb.addInst(PCodeInstruction.OpCode.DRF);
					}
				}

				break;
			case FUNCTION:
				// Los parámetros ya estarán apilados
				cb.addOSFInst(st.getDirBase(), st.level-s.nivel, ((SymbolFunction) s).label);
				break;

			case PROCEDURE:
				//p Los parámetros ya estarán apilados
				cb.addOSFInst(st.getDirBase(), st.level-s.nivel, ((SymbolProcedure) s).label);
				break;
			// si es por ref -> srf
			// si no -> srf + drf
		}
		return semanticResult;
    }
	|    
	id = <tID> /*var. o func. sin pars*/ {
		TypeValue semanticResult = SemanticFunctions.var_o_func_sin_params(id, st);
		// generar codigo
	
		// mirar ts con id.img para obtener el Symbol.dir
		s = st.getSymbol(id.image);
		//System.out.println(id.image + "(" + id.beginLine + ")  -> " + at.state.toString() + ": Params -> " + (at.paramIsRefInvocacion != null ? at.paramIsRefInvocacion.toString() : "ES NULL"));
		// Es una variable por referencia si esta en una invocación de un proc/func y consumo de la cola si el parámetro
		// que se está reconociendo es por referencia
		// Attributes.State.EnInvocación significa que lo evaluado es un parámetro de una función o procedimiento que está
		// siendo invocado y consumimos la cola de si el parámetro actual es por referencia o por valor
		boolean expectsARefAsign = at.state == Attributes.State.EnAsignacion;
		boolean expectsARefInv = !expectsARefAsign && at.state == Attributes.State.EnInvocacion && at.consumeQueue();

		switch (s.type) {
			case ARRAY:
				// si id es vector
				
				if (expectsARefInv || expectsARefAsign) {
					//Si el resultado es una referencia
					
					if(s.parClass == Symbol.ParameterClass.REF) {
						// si id es una ref -> srf + drf   Estás anidado y la variable ya era por ref
						if(Constants.comments) cb.addComment("Vector por referencia pasado a parámetro por referencia");
						cb.addInst(PCodeInstruction.OpCode.SRF, st.level-s.nivel, s.dir);
						cb.addInst(PCodeInstruction.OpCode.DRF);
					} else {
						// si no, id valor es un valor pero pide una referencia -> srf
						if(Constants.comments) cb.addComment("Vector por valor pasado a parámetro por referencia");			
						cb.addInst(PCodeInstruction.OpCode.SRF, st.level-s.nivel, s.dir);
					}
				} else {
					// Si el resultado es un valor
					// O no está en una invocación a proc/func -> Se quiere el valor de la variable
					// O estás en invocación pero el parámetro es por valor -> Se quiere el valor de la variable
					
					if(s.parClass == Symbol.ParameterClass.REF){
						// Tenemos la referencia al vector que hay que pasar por valor
						// si id es una ref -> srf + drf (ahora tienes @vector) + (n-1)*(srf + drf) (cargas todas las componentes con el offset en un bucle)
						if(Constants.comments) cb.addComment("Vector por referencia pasado a parámetro por valor");
						// Ahora se tiene en la pila la dirección del vector pero como se espera el valor del mismo hay que apilar todas sus componentes
						for (int i = 0; i < ((SymbolArray) s).maxInd - ((SymbolArray) s).minInd +1; i++) {
							cb.addInst(PCodeInstruction.OpCode.SRF, st.level-s.nivel, s.dir);
							cb.addInst(PCodeInstruction.OpCode.DRF);
							cb.addInst(PCodeInstruction.OpCode.STC, i); 
							cb.addInst(PCodeInstruction.OpCode.PLUS); // @vector[i]
							cb.addInst(PCodeInstruction.OpCode.DRF);
						}
					}else {
						// Tenemos el valor del vector y hay que pasarlo por valor
						// si no -> n*(srf + drf)
						if(Constants.comments) cb.addComment("Vector por valor pasado por parámetro por valor");
						for(int i = 0; i < ((SymbolArray) s).maxInd - ((SymbolArray) s).minInd +1; i++) {
							cb.addInst(PCodeInstruction.OpCode.SRF, st.level-s.nivel, s.dir + i);
							cb.addInst(PCodeInstruction.OpCode.DRF);
						}
					}
				}
				break;
			case FUNCTION:
				// si id es funcion/proc -> osf
				cb.addOSFInst(st.getDirBase(), st.level-s.nivel, ((SymbolFunction) s).label);
				break;

			case PROCEDURE:
				// si id es funcion/proc -> osf
				cb.addOSFInst(st.getDirBase(), st.level-s.nivel, ((SymbolProcedure) s).label);
				break;

			default: // Es escalar		
				if (expectsARefInv || expectsARefAsign) {
					// Si se espera una referencia
					if (s.parClass == Symbol.ParameterClass.REF) {
						// si id es una ref -> srf + drf
						cb.addInst(PCodeInstruction.OpCode.SRF, st.level-s.nivel, s.dir);
						cb.addInst(PCodeInstruction.OpCode.DRF);
					} else {
						// si no -> srf
						cb.addInst(PCodeInstruction.OpCode.SRF, st.level-s.nivel, s.dir);
					}
				} else {
					// si se espera un valor
					if ( s.parClass == Symbol.ParameterClass.REF) {
						// si id es una ref -> srf + drf + drf
						cb.addInst(PCodeInstruction.OpCode.SRF, st.level-s.nivel, s.dir);
						cb.addInst(PCodeInstruction.OpCode.DRF);
						cb.addInst(PCodeInstruction.OpCode.DRF);
					} else { 
						// si no -> srf + drf
						cb.addInst(PCodeInstruction.OpCode.SRF, st.level-s.nivel, s.dir);
						cb.addInst(PCodeInstruction.OpCode.DRF);
					}
				}
				break;
		}
		

		// usada para cuando estas en inst get/put/put_line
		// get -> Attributes.ioInst -> RD
		//at.cbInst(s.type, cb);
		return semanticResult;
    }
}


ArrayList<TypeValue> lista_una_o_mas_exps(Attributes at, CodeBlock cb) :
{
    ArrayList<TypeValue> exps = new ArrayList<TypeValue>();
    TypeValue exp;
}
{
    exp = expresion(at, cb) {
		if (exp.type != Symbol.Types.STRING) at.cbInst(exp.type, cb);
		if (at.state == Attributes.State.EnInvocacion && at.dequeueMethod == Attributes.DequeueMethod.Remove) at.consumeQueue();
	} exps = lista_exps_ll(at, cb) {
		exps.add(0, exp);
		return exps;
    }
}


ArrayList<TypeValue> lista_exps_ll(Attributes at, CodeBlock cb) :
{
    ArrayList<TypeValue> exps = new ArrayList<TypeValue>();
    TypeValue exp;
}
{
    <tCOMA> exp = expresion(at, cb) {
		if (exp.type != Symbol.Types.STRING) at.cbInst(exp.type, cb);
		if (at.state == Attributes.State.EnInvocacion && at.dequeueMethod == Attributes.DequeueMethod.Remove) at.consumeQueue();
	} exps = lista_exps_ll(at, cb) {
		exps.add(0, exp);
		return exps;
    }
    | {return exps;}
}


TOKEN_MGR_DECLS : {
    static void CommonTokenAction(Token token) {
		if (token.kind == tRESTO) {
			System.err.println("ERROR LEXICO: (" + token.beginLine + ", " + token.beginColumn + "): simbolo no reconocido: " + token.image);
			Constants.errorFree = false;
		}
		System.err.println("(" + token.beginLine + ", " + token.beginColumn + "): " + alikeConstants.tokenImage[token.kind] + " " + token.image);
		System.err.println();
    }
    
}


