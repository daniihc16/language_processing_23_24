//*****************************************************************
// File:   cl.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
// Date:   julio 2023
// Coms:   compilar mediante "ant"
//*****************************************************************

options {
    IGNORE_CASE = true;    //No distinguir entre mayúsculas y minúsculas
    COMMON_TOKEN_ACTION = false; //Se generan acciones por defecto
    DEBUG_PARSER = false; //Genera información de depuración
}

PARSER_BEGIN(alike)

package traductor;

import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import java.util.*;
import lib.tools.TypeValue;
import lib.tools.SemanticFunctions;
import lib.tools.exceptions.*;
import lib.tools.Constants;
import lib.tools.codeGeneration.*;
import lib.tools.Attributes;
import java.io.*;



public class alike {
   //...
	public static SymbolTable st = new SymbolTable();
	public static void main(String[] args) {
		alike parser = null;
		
		// Parseamos las opciones de la línea de comandos para inicializar las Constants
		// flags posibles: -v, -x, -v = verbose, -x = xmlOutput
		int i = 0;
		while (i < args.length && args[i].startsWith("-")) {
			System.out.println("Argumento: " + args[i]);
			if (args[i].equals("-v")) {
				Constants.verbose = true;
			} else if (args[i].equals("-x")) {
				Constants.xmlOutput = true;
			}
			i++;
		}
		// Si no se ha especificado un fichero de entrada se da error, se usa el nombre del fichero de entrada	
		if (i == args.length) {
			System.err.println("Uso: java -jar alike [-v] [-x] fichero_entrada.alike [fichero_salida.pcode]");
			System.exit(1);
		}

		

		try {
			if(args.length == 0) {
				parser = new alike(System.in);
			}
			else {
				parser = new alike(new java.io.FileInputStream(args[i]));
			}
			//Programa es el símbolo inicial de la gramática
			parser.Programa(args[args.length - 1].split("\\.")[0] + "DL.pcode");
			//...
			System.out.println("***** Análisis terminado con éxito *****");
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
			System.err.println("LEX_ERROR: " + e.getMessage());
			Constants.errorFree = false;

		}
		catch (ParseException e) {
			System.err.println("SYNTAX_ERROR: " + e.getMessage());
			Constants.errorFree = false;
		}
		//...
   }
}
PARSER_END(alike)
<COMILLAS> SKIP: { "\"" : DEFAULT }
SKIP : { <tCOMMENT :"--" (~["\n"])* "\n"> | " " |  "\n" |  "\t"|  "\r" }

TOKEN : {
    < #LETTER: (["a"-"z","A"-"Z"]) >
|    < #DIGIT: ["0"-"9"] >

}

TOKEN : {
    //Propios del programa
    < tBEGIN: "begin" >
|   < tEND: "end" >
|   < tASIGN: ":=" >
|   < tREF: "ref" >
|   < tIS: "is" >
|   < tOF: "of" >
|   < tPROC: "procedure" >
|   < tFUNC: "function" >
|   < tNULL: "null" >
|   < tARRAY: "array" >
|   < tRETURN: "return" >
|   < tEXIT: "exit" >


    //Tipos de datos
|   < tCHAR: "character" >
|   < tBOOL: "boolean" >
|   < tINT: "integer" >
|   < tCHARCONST: "\'" ~["\n"] "\'" >
|   < tINTCONST: (<DIGIT>)+ >
|   < tTRUE: "true" >
|   < tFALSE: "false" >
|   < tSTRING: "\"" ((~["\n", "\""])* ("\"\"")? )* "\""  > {
    // quitamos la doble "" por "
    matchedToken.image = image.toString().replaceAll("\"\"", "\"");
}

    //Operadores
|   <tAND: "and" >
|   <tOR: "or" >
|   <tNOT: "not" >
|   < tPLUS: "+" >
|   < tMINUS: "-" >
|   < tTIMES: "*" >
|   < tDIV: "/" >
|   < tLT: "<" >
|   < tGT: ">" >
|   < tEQ: "=" >
|   < tNE: "/=" >
|   < tLE: "<=" >
|   < tGE: ">=" >
|   < tMOD: "mod" >
|   < tAPAR: "(" >
|   < tCPAR: ")" >
|   < tPC: ";" >
|   < tDP: ":" >
|   < tCOMA: "," >
|   < tRANGE: ".." >
// Built in functions
|   < tSKIPLINE: "skip_line" >
|   < tGET: "get" >
|   < tPUTLINE: "put_line" >
|   < tPUT: "put" >
|   < tINT2CHAR: "int2char" >
|   < tCHAR2INT: "char2int" >

//Condicionales
|   < tIF: "if" >
|   < tELSE: "else" >
|   < tELSIF: "elsif" >
|   < tTHEN: "then" >
|   < tWHILE: "while" >
|   < tLOOP: "loop" >

//Identificadores
|   < tID: ( <LETTER> |"_") (<LETTER> | <DIGIT> | "_")* >
|   < tRESTO: ~[] >
   
}


Token boolconst():
{
    Token bool_const = null;
}
{
    ( bool_const = <tTRUE> | bool_const = <tFALSE>) { return bool_const; }
}

// Devuelve el array con los símbolos de los identificadores con su tipo
// @param ids: lista de identificadores a los que se les va a asignar un tipo
// @param ref: token que indica si el tipo es por referencia
ArrayList<Symbol> tipo_dato(ArrayList<String> ids, boolean isRef):
{
    ArrayList<Symbol> t;
    Token neg1 = null, neg2 = null, min, max;
}
{
    t = tipo_base(ids, isRef){
   	 	return t;
	}
    | <tARRAY> <tAPAR> ( neg1 = <tMINUS>)? min = <tINTCONST> <tRANGE> ( neg2 = <tMINUS>)?  max = <tINTCONST> <tCPAR> <tOF> t = tipo_base(ids, isRef) {
   	 return SemanticFunctions.simbolos_con_tipo(ids, isRef, t, min, max, neg1, neg2);
    }
}


// Devuelve el array con los símbolos de los identificadores con su tipo
// @param ids: lista de identificadores a los que se les va a asignar un tipo
// @param isRef: indica si el tipo es por referencia
ArrayList<Symbol> tipo_base(ArrayList<String> ids, boolean isRef):
{
    Symbol t;
}
{
    (<tCHAR> {t = new SymbolChar("");} | <tBOOL> {t = new SymbolBool("");} | <tINT>{t = new SymbolInt("");} ) {
   	 return SemanticFunctions.ids_simbolos_base(ids, isRef, t);
    }
}


// Devuelve el typevalue con el valor de la constante
// Apila el valor de la constante, y si es un string y se tiene que escribir también genera los WRT
TypeValue tipo_constante(Attributes at, CodeBlock cb):
{
    Token char_const = null;
    Token int_const = null;
    Token bool_const = null;
    Token string_const = null;
	TypeValue tv = null;
}
{
    char_const = <tCHARCONST> {
   	 	tv = new TypeValue(Symbol.Types.CHAR, char_const.image.charAt(1));
		if (Constants.errorFree) {
			cb.addComment("Storing constant character -> " + char_const.image.charAt(1));
			cb.addInst(PCodeInstruction.OpCode.STC, (int)(char)tv.value);
			at.cbInst(Symbol.Types.CHAR, cb);
		}
		return tv;
    } | int_const = <tINTCONST> {
		tv = new TypeValue(Symbol.Types.INT, Integer.parseInt(int_const.image));
		if (Constants.errorFree) {
			cb.addComment("Storing constant integer -> " + int_const.image);
			cb.addInst(PCodeInstruction.OpCode.STC, (int)tv.value);
			at.cbInst(Symbol.Types.INT, cb);
		}
		return tv;
    } | bool_const = boolconst() {
		tv = new TypeValue(Symbol.Types.BOOL, Boolean.parseBoolean(bool_const.image));
		if (Constants.errorFree) {
			cb.addComment("Storing constant boolean -> " + bool_const.image);
			cb.addInst(PCodeInstruction.OpCode.STC, (boolean)tv.value ? 1 : 0);
			at.cbInst(Symbol.Types.BOOL, cb);
		}
		return tv;
    } | string_const = <tSTRING> {
		tv = new TypeValue(Symbol.Types.STRING, string_const.image);
		if (Constants.errorFree) {
			// Recorremos el string y lo vamos apilando de final a inicio
			for (int i = 1; i < string_const.image.length() - 1; i++) {
				cb.addComment("Storing constant character -> " + string_const.image.charAt(i));
				cb.addInst(PCodeInstruction.OpCode.STC, (int)(string_const.image.charAt(i)));
				at.cbInst(Symbol.Types.CHAR, cb);
			}
		}
   	 	return tv;
    }
}


//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void Programa(String outputFile) :
{
    SymbolProcedure proc_main = null;
    ArrayList<Symbol> vars = null;
	Label labelMain = new Label(CGUtils.newLabel());;
	CodeBlock cb = new CodeBlock();
	CodeBlock cbProcsFuncs = new CodeBlock();
	CodeBlock insts = new CodeBlock();
}
{
   try {
		proc_main = cabecera_procedimiento(labelMain) {
			SemanticFunctions.insertSymbol(st, proc_main);
			st.setMainProc(proc_main.name);
			// generar etiqueta de procmain	
			cb.addComment("Entrada al programa");
			cb.addInst(PCodeInstruction.OpCode.ENP, labelMain.toString());
		}
		( vars = declaracion_variables() )? {
			if (vars != null) {
				for (Symbol var : vars) {
					SemanticFunctions.insertSymbol(st, var);
				}
				
			} else {
				vars = new ArrayList<Symbol>();
			}
			if(Constants.verbose) System.out.println("Nuevo símbolo: " + st.toString());
		}
		( cbProcsFuncs = declaracion_procs_funcs() {
			cb.addBlock(cbProcsFuncs);
		} )?
		<tBEGIN>
		{cb.addLabel(labelMain.toString() + ":");}
		( insts = instruccion(proc_main) {
			cb.addBlock(insts);
		} )*
		<tEND>
		<tPC>
		< EOF > { 
			if (Constants.errorFree) {
				try {
					if (Constants.xmlOutput) cb.encloseXMLTags("ProcedimientoPrincipal");

					BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));
					writer.write(cb.toString());
					writer.close();
					System.out.println("Generado código en " + outputFile);
				} catch (Exception e) {
					System.out.println("Error escribiendo en " + outputFile);
				}				
				
			} else System.err.println("***** No se ha generado código *****");
			
		}
    } catch (ParseException e) {
		System.err.println("SYNTAX_ERROR: " + e.getMessage());
		Constants.errorFree = false;


		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
    }

}


ArrayList<Symbol> declaracion_variables() :
{
    ArrayList<Symbol> vars = new ArrayList<Symbol>();
    ArrayList<Symbol> var_list = null;
}
{
    ( var_list = declaracion_var() {
   	 	for (Symbol var: var_list) vars.add(var);
    } )+ {
   	 	return vars;
    }
}
    

ArrayList<Symbol> declaracion_var() :
{
    ArrayList<String> ids;
    ArrayList<Symbol> vars;
}
{
    try {
		// tipo_dato devuelve el símbolo
		ids = lista_ids() <tDP> vars = tipo_dato(ids, false) <tPC> {
			return vars;
		}
    } catch (ParseException e) {
		System.err.println("SYNTAX_ERROR: " + e.getMessage());
		Constants.errorFree = false;


		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
		return new ArrayList<Symbol>();
    }
}


CodeBlock declaracion_procs_funcs() :
{
	CodeBlock cb = new CodeBlock();
	CodeBlock cbInternal = new CodeBlock();
}
{
    ( cbInternal = declaracion_proc() | cbInternal = declaracion_func() {
		System.out.println(cbInternal.toString());
		cb.addBlock(cbInternal);
	} )+ {
		return cb;
	
	}
}


// Reconoce la declaración de un procedimiento
// Inserta el símbolo del procedimiento en la tabla de símbolos
// Inserta bloque en la tabla de símbolos
// Inserta los parámetros y variables en la tabla de símbolos
CodeBlock declaracion_proc():
{
    SymbolProcedure proc = null;
    ArrayList<Symbol> vars = null;
	CodeBlock cb = new CodeBlock();
	Label labelProc = new Label(CGUtils.newLabel());
	CodeBlock cbProcsFuncs = new CodeBlock();
	CodeBlock insts = new CodeBlock();
}
{
    try {
		proc = cabecera_procedimiento(labelProc) {
			SemanticFunctions.newProcBlock(st, proc);
			// El lenguaje permite el uso de par´ametros escalares y de vectores, tanto por 
			// valor como por referencia en procedimientos y funciones
			// params
			// para cada param leyendo al revés
			//? Preguntar qué sentido tiene mover los valores de la pila principal al frame en lugar de tener punteros
			//? a la pila principal: mejor en caso de vectores por valor
			// void a(m, k: integer, z: array of integer)
			// a(x, y, z[]) -> push x (srf + drf); push y; push z  -> |					z3,z2,z1,y,x| -> push z..
				// si es por valor
					// si es escalar -> srf + asgi
					// si es vector -> n*(srf + asgi) (4n instrucciones entre apilar y desapilar) | 
				// si es por ref
					// si es escalar -> srf + asgi
					// si es vector -> srf + asgi
			
			if (Constants.errorFree) {
				// JMP para saltar al código del procc/func actual, sino se ejecutaría el código
				// de los procedimientos y funciones declarados internamente, que es lo que se encuentra
				// debajo de la declaración de la recuperación de los valores de los parámetros
				cb.addInst(PCodeInstruction.OpCode.JMP, labelProc.toString());
			}
		}
		( vars = declaracion_variables() )? {
			if (vars != null) {
				for (Symbol var : vars) SemanticFunctions.insertSymbol(st, var);
			} else {
				vars = new ArrayList<Symbol>();
			}
		}
		
		( cbProcsFuncs = declaracion_procs_funcs() {
			cb.addBlock(cbProcsFuncs);
		})?
		<tBEGIN>
		{cb.addLabel(labelProc.toString() + ":");}
		( insts = instruccion(proc) {
			cb.addBlock(insts);
		})+
		<tEND>
		<tPC>
		{
			if(Constants.verbose) System.out.println("Procedimiento reconocido: " + st.toString());
			st.removeBlock();
			if (Constants.errorFree && Constants.xmlOutput)	cb.encloseXMLTags("Procedimiento_" + proc.name);
			return cb;
		}
    } catch (ParseException e) {
		System.err.println("SYNTAX ERROR: " + e.getMessage());
		Constants.errorFree = false;
		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
		return cb;
    }
}


// Reconoce la declaración de una función
// Inserta el símbolo de la función en la tabla de símbolos
// Inserta bloque en la tabla de símbolos
// Inserta los parámetros y variables en la tabla de símbolos
CodeBlock declaracion_func():
{
    ArrayList<Symbol> vars = new ArrayList<Symbol>();
    SymbolFunction func = null;
	CodeBlock cb = new CodeBlock();
	Label labelFunc = new Label(CGUtils.newLabel());
	CodeBlock cbProcsFuncs = new CodeBlock();
	CodeBlock insts = new CodeBlock();
}
{
    
    try {
		func = cabecera_funcion(labelFunc) {
			SemanticFunctions.newFuncBlock(st, func);
			if (Constants.errorFree) {
				cb.addComment("Procedimiento " + func.name);
				cb.addInst(PCodeInstruction.OpCode.JMP, labelFunc.toString());
				if (Constants.xmlOutput) cb.encloseXMLTags("Función " + func.name);
			}
		}
		( vars = declaracion_variables() )? {
			if (vars != null) for (Symbol var : vars) SemanticFunctions.insertSymbol(st, var);
		}
		( cbProcsFuncs = declaracion_procs_funcs() {
			cb.addComment("Procedimientos y funciones internos");
			cb.addBlock(cbProcsFuncs);
		})?
		<tBEGIN>{cb.addLabel(labelFunc.toString() + ":");}
		( insts = instruccion(func) {
			cb.addBlock(insts);
		})+ // Pasamos el símbolo de la función para que se pueda comprobar el return
		<tEND>
		<tPC>
		{
			if(Constants.verbose) System.out.println("Función reconocida: " + st.toString());
			st.removeBlock();
			cb.encloseXMLTags(func.name);
			return cb;
		}
    } catch (ParseException e) {
		System.err.println("SYNTAX_ERROR: " + e.getMessage());
		Constants.errorFree = false;


		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
		return cb;
    }
}


ArrayList<Symbol> declaracion_param() :
{
    ArrayList<String> ids;
    ArrayList<Symbol> ids_con_tipo;
    Token ref = null;
}
{
    ids = lista_ids() <tDP> ( ref=<tREF> )? ids_con_tipo = tipo_dato(ids, ref != null)
    {
   	 	return ids_con_tipo;
    }
}


// Devuelve la lista de identificadores reconocidos
ArrayList<String> lista_ids() :
{
    ArrayList<String> ids = new ArrayList<String>();
    ArrayList<String> resto_ids = null;
    Token id;
}
{
    ( LOOKAHEAD(2) id = <tID> <tCOMA> resto_ids = lista_ids()
|    id = <tID>) {
		ids.add(id.image);
		if (resto_ids != null) {
			for (String sid : resto_ids) ids.add(sid);
		}
		return ids;
    }
}


// Devuelve el símbolo del procedimiento con los parámetros
SymbolProcedure cabecera_procedimiento(Label label):
{
    Token id_proc;
    ArrayList<Symbol> proc_params = null;
}
{
    <tPROC> id_proc = <tID> ( proc_params = parametros_formales() )? <tIS>
    {
   	 	return new SymbolProcedure(id_proc.image, proc_params, label.toString());
    }
}


// Devuelve el símbolo de la función con los parámetros
SymbolFunction cabecera_funcion(Label label):
{
    Token id_func;
    ArrayList<Symbol> func_params = null;
    ArrayList<Symbol> returnType = null;
    
}
{
    <tFUNC> id_func = <tID> ( func_params = parametros_formales() )? <tRETURN> returnType = tipo_base(new ArrayList<String>(Arrays.asList("returnType")), false) <tIS> {
		if (returnType.get(0).type != Symbol.Types.INT && returnType.get(0).type != Symbol.Types.BOOL && returnType.get(0).type != Symbol.Types.CHAR) {
			ArrayList<Symbol.Types> expectedTypes = new ArrayList<Symbol.Types>();
			expectedTypes.add(Symbol.Types.INT);
			expectedTypes.add(Symbol.Types.CHAR);
			expectedTypes.add(Symbol.Types.BOOL);
			UnexpectedTypeException.getMessage(expectedTypes, returnType.get(0).type, id_func.beginLine, id_func.beginColumn);
		}
   	 	return new SymbolFunction(id_func.image, func_params, returnType.get(0).type, label.toString());
    }
}


// Devuelve el array con los símbolos de los identificadores con su tipo
ArrayList<Symbol> parametros_formales():
{
    ArrayList<Symbol> params = new ArrayList<Symbol>();
    ArrayList<Symbol> ps, resto_p;
}
{
    try {
		( <tAPAR>    ps = declaracion_param() {
				for (Symbol p :  ps) params.add(p);
			}
		
			resto_p = lista_parametros_formales() {
				for (Symbol p :  resto_p) params.add(p);
			} <tCPAR> // con parámetros
		| "" ) // sin parámetros (épsilon)
    } catch (ParseException e) {
		System.err.println("SYNTAX_ERROR: " + e.getMessage());
		Constants.errorFree = false;


		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
    }
    { return params; }
}


ArrayList<Symbol> lista_parametros_formales():
{
    ArrayList<Symbol> params = new ArrayList<Symbol>();
    ArrayList<Symbol> ps, resto_p;
}
{
    (<tPC> ps = declaracion_param(){
		for (Symbol p :  ps) params.add(p);
	}
   	resto_p = lista_parametros_formales() {
   		for (Symbol p :  resto_p) params.add(p);
   	}
    ) { return params; }
    | { return params; }
}


//where es el símbolo de la función o el procedimiento en la que se encuentra la instrucción
//Usado para comprobar que el return tiene el tipo correcto y no hay return en procedimientos
CodeBlock instruccion(Symbol where) :
{
	CodeBlock cb = new CodeBlock();
}
{
    try {
		(  cb = inst_leer()
		|  cb = inst_skipline()
		|  cb = inst_escribir()
		|  cb = inst_escribir_linea()
		|  cb = inst_invocacion_o_asignacion()
		|  cb = inst_if(where)
		|  cb = inst_while(where)
		|  cb = inst_return(where)
		|  cb = inst_exit()
		|  <tNULL>) <tPC> {
			return cb;
		}
    } catch (ParseException e) {
		System.err.println("SYNTAX_ERROR: " + e.getMessage());
		Constants.errorFree = false;
		// Reconocer hasta el token <tPC>
		while (true) {
			Token t = getNextToken();
			if (t.kind == tPC) break;
		}
    }

}


CodeBlock inst_leer() :
{
    ArrayList<TypeValue> exps = null;
	Token get = null;	// Token usado para que en caso de error se pueda mostrar la línea y columna
	CodeBlock cb = new CodeBlock();
	Attributes attrs = new Attributes(Attributes.State.EnInvocacion, Attributes.DequeueMethod.Peek, PCodeInstruction.OpCode.RD);
	attrs.setQueue(Symbol.ParameterClass.REF);
}
{
    get = <tGET> <tAPAR> exps = lista_una_o_mas_exps(attrs, cb) <tCPAR> {
		SemanticFunctions.inst_leer(exps, get);
		if(Constants.verbose) System.out.println("Encontrada instrucción get correcta");
		if(Constants.errorFree && Constants.xmlOutput) cb.encloseXMLTags("get");
		return cb;
    }
}


CodeBlock inst_escribir() :
{
    ArrayList<TypeValue> exps = new ArrayList<TypeValue>();
	Token put = null;
	CodeBlock cb = new CodeBlock();
	Attributes attrs = new Attributes(Attributes.State.EnInvocacion, Attributes.DequeueMethod.Peek, PCodeInstruction.OpCode.WRT);
	attrs.setQueue(Symbol.ParameterClass.VAL);
}
{
    put = <tPUT> <tAPAR> exps = lista_una_o_mas_exps(attrs, cb) <tCPAR> {
		SemanticFunctions.inst_escribir(exps, put.beginLine, put.beginColumn);
		if(Constants.verbose) System.out.println("Encontrada instrucción put correcta");
		if(Constants.errorFree && Constants.xmlOutput) cb.encloseXMLTags("put");
		return cb;
    }
}


CodeBlock inst_escribir_linea() :
{
    ArrayList<TypeValue> exps = new ArrayList<TypeValue>();
	Token put = null;
	CodeBlock cb = new CodeBlock();
	Attributes attrs = new Attributes(Attributes.State.EnInvocacion, Attributes.DequeueMethod.Peek, PCodeInstruction.OpCode.WRT);
	attrs.setQueue(Symbol.ParameterClass.VAL);
}
{
    put = <tPUTLINE> (<tAPAR> exps = lista_una_o_mas_exps(attrs, cb)    <tCPAR>)? {
		SemanticFunctions.inst_escribir(exps, put.beginLine, put.beginColumn);
		if(Constants.verbose) System.out.println("Encontrada instrucción put_line correcta");
		if	(Constants.errorFree) {
			// Añadir un salto de línea al final en la generación de código
			cb.addComment("Salto de línea");

			cb.addInst(PCodeInstruction.OpCode.STC, 13); // CR
			cb.addInst(PCodeInstruction.OpCode.WRT, 0);
			
			cb.addInst(PCodeInstruction.OpCode.STC, 10); // LF
			cb.addInst(PCodeInstruction.OpCode.WRT, 0);
			
			if (Constants.xmlOutput) cb.encloseXMLTags("put_line");
		} 
		return cb;
	
    }
}


CodeBlock inst_invocacion_o_asignacion() :
{
	TypeValue p = null, exp = null;
	Token asign = null;
	CodeBlock cb = new CodeBlock();
	Attributes attrs = new Attributes(Attributes.State.EnInvocacion, Attributes.DequeueMethod.Remove);
}
{
	p = invoc_o_asign_primario(attrs, cb) (asign = <tASIGN> exp = expresion(attrs, cb))? {
		SemanticFunctions.inst_invocacion_o_asignacion(p, exp, asign);
		if(Constants.verbose) {
			if (asign != null) System.out.println("Invocación correcta en línea: " + String.valueOf(asign.beginLine));
			else System.out.println("Invocación correcta");
		}
		return cb;
	}
}


CodeBlock inst_if(Symbol sf) :
{
	TypeValue expif = null, expelsif = null;
	Token tif = null, elsif = null;
	CodeBlock cb = new CodeBlock();
	Attributes attrs = new Attributes(Attributes.State.Normal, Attributes.DequeueMethod.Remove);
}
{
    // debe haber por lo menos una instrucción en el bloque condicional (null en casos donde no se haga nada)
    tif = <tIF> expif = expresion(attrs, cb) <tTHEN> {
		SemanticFunctions.inst_if(expif, tif);
	} (instruccion(sf))+
    (elsif = <tELSIF> expelsif = expresion(attrs, cb) <tTHEN>  {
		SemanticFunctions.inst_if(expelsif, elsif);
	} (instruccion(sf))+ )*
    (<tELSE> (instruccion(sf))+)?
    <tEND> <tIF> {return cb;}
}


CodeBlock inst_while(Symbol sf) :
{
	TypeValue exp = null;
	Token twhile = null;
	CodeBlock cb = new CodeBlock();
	Attributes attrs = new Attributes(Attributes.State.Normal, Attributes.DequeueMethod.Remove);
}
{
    twhile = <tWHILE> exp = expresion(attrs, cb) <tLOOP> (instruccion(sf))+ <tEND> <tLOOP> {
		SemanticFunctions.inst_while(exp, twhile);
		if(Constants.verbose) System.out.println("Encontrada instrucción while correcta en línea: " + String.valueOf(twhile.beginLine));
		return cb; 
	}
}


CodeBlock inst_return(Symbol sf) :
{
	TypeValue exp = null;
	Token treturn = null;
	CodeBlock cb = new CodeBlock();
	Attributes attrs = new Attributes(Attributes.State.Normal, Attributes.DequeueMethod.Remove);
}
{
	treturn = <tRETURN> exp = expresion(attrs, cb) {
		SemanticFunctions.inst_return(exp, sf, treturn);
		if(Constants.verbose) System.out.println("Encontrada instrucción return correcta en línea: " + String.valueOf(treturn.beginLine));
		return cb;
	}
}


CodeBlock inst_exit() :
{
	Token texit = null;
	CodeBlock cb = new CodeBlock();
	Attributes attrs = new Attributes(Attributes.State.Normal, Attributes.DequeueMethod.Remove);
}
{
	texit = <tEXIT> {
		if(Constants.verbose) System.out.println("Encontrada instrucción exit correcta en línea: " + String.valueOf(texit.beginLine));
		return cb;
	}
}


CodeBlock inst_skipline() : 
{
	CodeBlock cb = new CodeBlock();
	Attributes attrs = new Attributes(Attributes.State.Normal, Attributes.DequeueMethod.Remove);
}
{
	<tSKIPLINE> {return cb;}
}


TypeValue expresion(Attributes at, CodeBlock cb):
{
    TypeValue prel = null, srel = null;
    Token op = null;
	TypeValue result = null;
	// "and" y "or" son asociativos a la izqda. pero mezclados, no está definida su asociatividad, por lo que hay que usar paréntesis que definan la prioridad de las operaciones.
}
{
	
	prel = relacion(at, cb) ((op = <tAND> srel = relacion(at, cb) {
		result = SemanticFunctions.expresion(srel, result, op, tAND, tOR);
	})+ 
	| (op = <tOR> srel = relacion(at, cb) {
		result = SemanticFunctions.expresion(srel, result, op, tAND, tOR);
	})+)? {
	 	return SemanticFunctions.expresion(prel, result, op, tAND, tOR);
    }
}



TypeValue relacion(Attributes at, CodeBlock cb):
{
    TypeValue exp1 = null, exp2 = null;    
    Token op = null;
}
{
	exp1 = expresion_simple(at, cb)
	( op = operador_relacional() exp2 = expresion_simple(at, cb) )? {
		if(Constants.verbose) System.out.println("Encontrada relación correcta");
		if(Constants.errorFree){
			if (op != null) {
				cb.addComment("Relación " + op.image);
				switch(op.kind) {
					case tEQ: cb.addInst(PCodeInstruction.OpCode.EQ); break;
					case tNE: cb.addInst(PCodeInstruction.OpCode.NEQ); break;
					case tLT: cb.addInst(PCodeInstruction.OpCode.LT); break;
					case tLE: cb.addInst(PCodeInstruction.OpCode.LTE); break;
					case tGT: cb.addInst(PCodeInstruction.OpCode.GT); break;
					case tGE: cb.addInst(PCodeInstruction.OpCode.GTE); break;
				}
			}
			
		} 
		return SemanticFunctions.relacion(exp1, op, exp2, tEQ, tNE, tLT, tLE, tGT, tGE);
    }
}


Token operador_relacional():
{
    Token t;
}
{
    (t = <tEQ> | t = <tNE> | t = <tLT> | t = <tLE> | t = <tGT> | t = <tGE>) { return t; }
}


TypeValue expresion_simple(Attributes at, CodeBlock cb):
{
    TypeValue term = null, term_resultante = null;
    Token op = null, ops = null;
}
{
	( ops = <tPLUS> | ops =    <tMINUS> )?
	term = termino(at, cb)  (( op = <tPLUS> | op = <tMINUS> ) term_resultante = una_o_mas_expresiones_simples(at, cb))? {
		return SemanticFunctions.expresion_simple(ops, term, op, term_resultante, tPLUS, tMINUS);
    }
}


TypeValue una_o_mas_expresiones_simples(Attributes at, CodeBlock cb):
{
    TypeValue term = null, term_resultante = null;
    Token op = null, ops = null;
}
{
    term = termino(at, cb) (( op = <tPLUS> | op = <tMINUS> ) term_resultante = una_o_mas_expresiones_simples(at, cb))? {
   	 return SemanticFunctions.una_o_mas_expresiones_simples(term, op, term_resultante, tPLUS, tMINUS);
    }
}


TypeValue termino(Attributes at, CodeBlock cb):
{
    TypeValue fact = null, fact_resultante = null;
    Token op = null;
}
{
    fact = factor(at, cb) ( op = operador_multiplicativo() fact_resultante = lista_una_o_mas_terminos(at, cb) )? {
		return SemanticFunctions.termino(fact, op, fact_resultante, tTIMES, tDIV, tMOD);
    }
}


TypeValue lista_una_o_mas_terminos(Attributes at, CodeBlock cb):
{
    TypeValue fact = null, fact_resultante = null;
    Token op = null;
}
{
    fact = factor(at, cb) ( op = operador_multiplicativo() fact_resultante = lista_una_o_mas_terminos(at, cb))? {
   	 	return SemanticFunctions.termino(fact, op, fact_resultante, tTIMES, tDIV, tMOD);
    }
}


Token operador_multiplicativo() :
{
    Token t;
}
{
    (t = <tTIMES> | t = <tDIV> | t = <tMOD>) { return t; }
}


TypeValue factor(Attributes at, CodeBlock cb):
{
    TypeValue p = null;
	Token not = null;
}
{
    p = primario(at, cb) {
   	 return p;
    }
    | not = <tNOT> p = primario(at, cb) {
		return SemanticFunctions.not_primario(p, not.beginLine, not.beginColumn);
    }
}


TypeValue primario(Attributes at, CodeBlock cb) :
{
    TypeValue exp = null;
    Token id = null, fnToken = null;
}
{
	<tAPAR> exp = expresion(at, cb) <tCPAR> { return exp; } // new Attributes 
|    fnToken = <tINT2CHAR> <tAPAR> exp = expresion(at, cb) <tCPAR> {
    // System.out.println(exp.value);
    if (exp.type != Symbol.Types.INT) UnexpectedTypeException.getMessage(Symbol.Types.INT, exp.type, fnToken.beginLine, fnToken.beginColumn);
	// en gen. de código comprobar que el valor es mayor que 0 ?? 
	return new TypeValue(Symbol.Types.CHAR, exp.value);
}	
|    fnToken = <tCHAR2INT> <tAPAR> exp = expresion(at, cb) <tCPAR> {
	if (exp.type != Symbol.Types.CHAR) UnexpectedTypeException.getMessage(Symbol.Types.CHAR, exp.type, fnToken.beginLine, fnToken.beginColumn);
	return new TypeValue(Symbol.Types.INT, null);

}
|    exp = invoc_o_asign_primario(at, cb) {return exp;}
|    exp = tipo_constante(at, cb) { return exp; }
}


// Reconoce a un invocado o a un asignado
TypeValue invoc_o_asign_primario(Attributes at, CodeBlock cb):
{
	TypeValue exp = null;
    Token id = null;
	ArrayList<TypeValue> exps = null;
}
{
	LOOKAHEAD(2) id = <tID> <tAPAR> {
		// distinguir si id es func/proc o array
		Symbol s = st.getSymbol(id.image);
		if (s.type == Symbol.Types.FUNCTION) at.setQueue(((SymbolFunction) s).parList);
		else if (s.type == Symbol.Types.PROCEDURE) at.setQueue(((SymbolProcedure) s).parList);
		// si es func/proc -> instanciar attributes a "EnInvocacion" + poner en attributes todos los parámetros y sus tipos (val/ref)
		// si es array -> no hace falta, todo es por valor
	} exps = lista_una_o_mas_exps(at, cb) <tCPAR> /*invoc. func. o comp. array*/ {
		TypeValue semanticResult = SemanticFunctions.invoc_func_o_comp_array(id, exps, st);
		// mirar ts con id.img para obtener el Symbol.dir
		// si id es func/proc -> apilar + osf
		// si id es comp. vector
			// si es por ref -> srf
			// si no -> srf + drf
		return semanticResult;
    }
	|    
	id = <tID> /*var. o func. sin pars*/ {
		TypeValue semanticResult = SemanticFunctions.var_o_func_sin_params(id, st);
		// generar codigo
	
		// mirar ts con id.img para obtener el Symbol.dir
		Symbol s = st.getSymbol(id.image);
		
		// Es una variable por referencia si esta en una invocación de un proc/func y consumo de la cola si el parámetro
		// que se está reconociendo es por referencia
		boolean porRefEnInv = at.state == Attributes.State.EnInvocacion && at.consumeQueue();

		switch (s.type) {
			case ARRAY:
			// si id es vector
			
				// si id es una ref -> srf + drf (ahora tienes @vector) + n*(srf + drf) (cargas todas las componentes con el offset en un bucle)
				// si no -> n*(srf + drf)
				if (porRefEnInv) {
					// si se pasa por ref

					if(s.parClass == Symbol.ParameterClass.REF) {
						// si id es una ref -> srf + drf   Estás anidado y la variable ya era por ref
						cb.addComment("Vector por referencia pasado a parámetro por referencia");
						cb.addInst(PCodeInstruction.OpCode.SRF, s.nivel, s.dir);
						cb.addInst(PCodeInstruction.OpCode.DRF);
					} else {
						// si no, id valor es un valor pero pide una referencia -> srf
						cb.addComment("Vector por valor pasado a parámetro por referencia");			
						cb.addInst(PCodeInstruction.OpCode.SRF, s.nivel, s.dir);
					}
				} else {
					// O no está en una invocación a proc/func -> Se quiere el valor de la variable
					// O estás en invocación pero el parámetro es por valor -> Se quiere el valor de la variable
					
					if(s.parClass == Symbol.ParameterClass.REF){
						// Tenemos la referencia al vector que hay que pasar por valor
						// si id es una ref -> srf + drf (ahora tienes @vector) + (n-1)*(srf + drf) (cargas todas las componentes con el offset en un bucle)
						cb.addComment("Vector por referencia pasado a parámetro por valor");
						// Ahora se tiene en la pila la dirección del vector pero como se espera el valor del mismo hay que apilar todas sus componentes
						for (int i = 0; i < ((SymbolArray) s).maxInd - ((SymbolArray) s).minInd; i++) {
							cb.addInst(PCodeInstruction.OpCode.SRF, s.nivel, s.dir);
							cb.addInst(PCodeInstruction.OpCode.DRF);
							cb.addInst(PCodeInstruction.OpCode.STC, i); 
							cb.addInst(PCodeInstruction.OpCode.PLUS); // @vector[i]
							cb.addInst(PCodeInstruction.OpCode.DRF);
						}
					}else {
						// Tenemos el valor del vector y hay que pasarlo por valor
						// si no -> n*(srf + drf)
						cb.addComment("Vector por valor pasado por parámetro por valor");
						for(int i = 0; i < ((SymbolArray) s).maxInd - ((SymbolArray) s).minInd; i++) {
							cb.addInst(PCodeInstruction.OpCode.SRF, s.nivel, s.dir + i);
							cb.addInst(PCodeInstruction.OpCode.DRF);
						}
					}
				}
				break;
			case FUNCTION:
				// si id es funcion/proc -> osf
				cb.addOSFInst(st.level, st.level-s.nivel, ((SymbolFunction) s).label);
				break;

			case PROCEDURE:
				// si id es funcion/proc -> osf
				cb.addOSFInst(st.level, st.level-s.nivel, ((SymbolProcedure) s).label);
				break;

			default: // Es escalar		
				// si se pasa por ref 
				if (porRefEnInv) {
					// si id es una ref -> srf + drf
					if (s.parClass == Symbol.ParameterClass.REF) {
						// si id es una ref -> srf + drf
						cb.addInst(PCodeInstruction.OpCode.SRF, s.nivel, s.dir);
						cb.addInst(PCodeInstruction.OpCode.DRF);
					} else {
						// si no -> srf
						cb.addInst(PCodeInstruction.OpCode.SRF, s.nivel, s.dir);
					}
				} else {
					// si id es una ref -> srf + drf + drf
					if ( s.parClass == Symbol.ParameterClass.REF) {
						cb.addInst(PCodeInstruction.OpCode.SRF, s.nivel, s.dir);
						cb.addInst(PCodeInstruction.OpCode.DRF);
						cb.addInst(PCodeInstruction.OpCode.DRF);
					} else { // si no -> srf + drf
						cb.addInst(PCodeInstruction.OpCode.SRF, s.nivel, s.dir);
						cb.addInst(PCodeInstruction.OpCode.DRF);
					}
				}
				break;
		}
		

		// usada para cuando estas en inst get/put/put_line
		// get -> Attributes.ioInst -> RD
		//attrs.cbInst(type, cb);
		return semanticResult;
    }
}


ArrayList<TypeValue> lista_una_o_mas_exps(Attributes at, CodeBlock cb) :
{
    ArrayList<TypeValue> exps = new ArrayList<TypeValue>();
    TypeValue exp;
}
{
    exp = expresion(at, cb) exps = lista_exps_ll(at, cb) {
		exps.add(0, exp);
		return exps;
    }
}


ArrayList<TypeValue> lista_exps_ll(Attributes at, CodeBlock cb) :
{
    ArrayList<TypeValue> exps = new ArrayList<TypeValue>();
    TypeValue exp;
}
{
    <tCOMA> exp = expresion(at, cb) exps = lista_exps_ll(at, cb) {
		exps.add(0, exp);
		return exps;
    }
    | {return exps;}
}


TOKEN_MGR_DECLS : {
    static void CommonTokenAction(Token token) {
		if (token.kind == tRESTO) {
			System.err.println("ERROR LEXICO: (" + token.beginLine + ", " + token.beginColumn + "): simbolo no reconocido: " + token.image);
			Constants.errorFree = false;
		}
		System.err.println("(" + token.beginLine + ", " + token.beginColumn + "): " + alikeConstants.tokenImage[token.kind] + " " + token.image);
		System.err.println();
    }
    
}


